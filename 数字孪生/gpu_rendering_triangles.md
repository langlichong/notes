# 为什么显卡 (GPU) 只认三角形？(深度详解版)

*针对您关心的四个核心图形学概念进行了深度增补。*

---

## 1. 为什么三角形是“天选之子”？

显卡选择三角形作为基本图元，不是因为懒，而是因为数学上的三个完美特性：

### A. 永远共面 (Coplanar) & 法线问题

> **用户提问：为什么要算法线 (Normal)？**

*   **什么是法线？**
    法线是一条垂直于平面的线，它告诉计算机**“这个面朝向哪里”**。
*   **为什么要算它？(为了光照)**
    计算机算光照的公式非常简单：`亮度 = 光线方向 · 法线方向`。
    *   面朝灯光（夹角小） -> 亮。
    *   背向灯光（夹角大） -> 暗。
*   **四边形的麻烦**：
    如果你用 4 个点（四边形），这 4 个点可能**不在同一个平面上**（例如把一张纸对折）。这时候，这个面到底是朝左看还是朝右看？计算机不知道。
    *   **后果**：法线无法确定 -> 光照计算错误 -> 画面在闪烁。
    *   **三角形的解**：三个点永远在一个平面上，法线方向是唯一确定的，光照永远稳定。

### B. 永远凸 (Convex)

> **用户提问：解释凸多边形及其应用？**

*   **含义**：
    *   **凸多边形**：你在图形内部随便找两个点连一条线，这条线**一定完全在图形内部**。三角形永远是凸的。
    *   **凹多边形**：比如一个“飞镖”形状或“五角星”。连线可能会跑到外面去。
*   **应用 (光栅化算法)**：
    显卡在填色（Rasterization）时，是用“扫描线”从上到下一行行扫的。
    *   **对于凸多边形 (三角形)**：扫描线每一行只进一次、出一次。算法极简，速度极快。
    *   **对于凹多边形**：扫描线可能会进、出、再进、再出。显卡需要极其复杂的逻辑去判断“我现在到底在里面还是外面”，这会严重拖慢渲染速度。

### C. 插值简单 (Barycentric Interpolation)

> **用户提问：重心坐标插值的应用场景？**

*   **问题场景**：
    三角形有三个顶点：A是红色，B是蓝色，C是绿色。那么三角形**中间**的那一个像素点应该是什么颜色？
*   **重心坐标插值**：
    这是一种数学魔法，它能根据这个像素点距离 A、B、C 的远近权重，自动算出混合颜色。
*   **核心应用**：
    1.  **贴图映射 (UV)**：顶点知道自己对应图片的哪个坐标，中间的像素通过插值才知道自己该贴图的哪一部分。没有它，模型就是一团纯色，贴不上图。
    2.  **光滑着色 (Smooth Shading)**：让低模看起来圆润，其实是通过插值“伪造”了中间的法线。

---

## 2. 只有三角形吗？现代技术的突破

### 软件光栅化 (Software Rasterization)

> **用户提问：解释这一概念？**

*   **硬件光栅化 (标准)**：
    使用显卡上专门的电路模块（Rasterizer）来画三角形。甚至快，但有个死穴：**当三角形比像素点还小时**（比如一个三角形只占屏幕 0.1 个像素），硬件效率会暴跌（Overdraw）。
*   **软件光栅化 (Nanite黑科技)**：
    不走显卡的专用电路，而是用显卡的通用计算单元 (Compute Shader) 写**代码**来画点。
    *   **Nanite 原理**：当模型离得很远，三角形极其微小时，Unreal 引擎会自动切换到“软件光栅化”模式，直接用代码判断这个像素点是否被遮挡，而不走传统的三角形流水线。
    *   **意义**：这就是为什么 UE5 可以渲染**无限多**的多边形而卡不顿，因为它绕过了硬件光栅化对小三角形的物理限制。
