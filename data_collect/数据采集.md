å¯æ’æ‹”é‡‡é›†åè®®
ä¸»å¹³å°æ¶æ„ä½¿ç”¨æ ‡å‡†æ¨¡å—åŒ– + PF4J æ’ä»¶ç³»ç»Ÿ
æ’ä»¶é‡‡é›†é€»è¾‘å¼‚æ­¥ã€çº¿ç¨‹å®‰å…¨ï¼Œä¸å½±å“å¹³å°ä¸»çº¿ç¨‹
æ’ä»¶ â‰  å•ä¸€è®¾å¤‡é‡‡é›†å™¨ï¼Œè€Œæ˜¯ä¸€ä¸ªåè®®é€‚é…å™¨ + å¤šè®¾å¤‡ç®¡ç†å™¨

**é©±åŠ¨-è°ƒåº¦å™¨-ä»»åŠ¡æ¨¡å¼**

```tex
åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œä¸€ä¸ª**â€œé©±åŠ¨â€ä¸å†æ˜¯ç®€å•çš„ä»£ç å—ï¼Œè€Œæ˜¯ä¸€ä¸ªâ€œåè®®ç®¡ç†å™¨â€æˆ–â€œåè®®å·¥å‚â€**ã€‚å®ƒè´Ÿè´£å¤„ç†ä¸æŸç§åè®®ï¼ˆå¦‚ Modbusã€MQTTï¼‰ç›¸å…³çš„åº•å±‚é€šä¿¡ï¼Œä½†æœ¬èº«ä¸è´Ÿè´£å…·ä½“çš„é‡‡é›†é€»è¾‘ã€‚

é©±åŠ¨ï¼ˆDriverï¼‰ï¼šè´Ÿè´£ç®¡ç†ä¸åº•å±‚ç¡¬ä»¶æˆ–ç½‘ç»œçš„è¿æ¥æ± ï¼Œå¤„ç†æ•°æ®çš„å‘é€å’Œæ¥æ”¶ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ª Modbus TCP é©±åŠ¨ä¼šç»´æŠ¤ä¸å¤šä¸ª Modbus ä»ç«™çš„è¿æ¥ï¼Œå¹¶å¤„ç†è¯»å†™è¯·æ±‚çš„é€šä¿¡ç»†èŠ‚ã€‚

é‡‡é›†ä»»åŠ¡ï¼ˆCollection Taskï¼‰ï¼šè¿™æ˜¯æœ€å°çš„å·¥ä½œå•å…ƒã€‚æ¯ä¸ªä»»åŠ¡éƒ½ä¸ä¸€ä¸ªç‰¹å®šçš„è®¾å¤‡ã€ç‰¹å®šçš„æ•°æ®ç‚¹ä»¥åŠç‰¹å®šçš„é‡‡é›†é¢‘ç‡ç›¸å…³è”ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªä»»åŠ¡å¯èƒ½æ˜¯ï¼šâ€œæ¯ 5 ç§’è¯»å–è®¾å¤‡ A çš„æ¸©åº¦ä¼ æ„Ÿå™¨å€¼â€ã€‚

è°ƒåº¦å™¨ï¼ˆSchedulerï¼‰ï¼šè¿™æ˜¯æ•´ä¸ªç³»ç»Ÿçš„æ ¸å¿ƒã€‚å®ƒè´Ÿè´£ç®¡ç†æ‰€æœ‰çš„é‡‡é›†ä»»åŠ¡ï¼Œå¹¶æ ¹æ®æ¯ä¸ªä»»åŠ¡è®¾å®šçš„é¢‘ç‡ï¼Œåœ¨é€‚å½“çš„æ—¶æœºå°†ä»»åŠ¡æ´¾å‘ç»™ç›¸åº”çš„é©±åŠ¨ã€‚

```

**è™šæ‹Ÿçº¿ç¨‹æ¶æ„ä¸­çš„ä¸€ä¸ªå…³é”®è®¾è®¡ç‚¹ï¼šåˆ†ç¦»è°ƒåº¦å’Œæ‰§è¡Œã€‚ç®€å•æ¥è¯´ï¼Œä½ éœ€è¦è¿™ä¸¤ä¸ªçº¿ç¨‹æ± æ˜¯å› ä¸ºå®ƒä»¬æ‰®æ¼”ç€ä¸åŒçš„è§’è‰²**

- è°ƒåº¦å™¨ (ScheduledExecutorService) çš„è§’è‰²: å®šæ—¶è§¦å‘äº‹ä»¶
- è™šæ‹Ÿçº¿ç¨‹æ‰§è¡Œå™¨ (VirtualThreadPerTaskExecutor) è§’è‰²: æ‰§è¡Œä»»åŠ¡

 PF4J / Spring SPI



â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Quartz è°ƒåº¦å™¨â”‚â”€â”€â”€â–¶  â”‚é‡‡é›†ä»»åŠ¡äº‹ä»¶â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                     â”‚
     â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç²¾å‡†è°ƒåº¦è®¾å¤‡â”‚     â”‚ç»Ÿä¸€å‘¨æœŸè®¾å¤‡é‡‡é›†å™¨â”‚ï¼ˆReactor/Vert.xï¼‰
â”‚ (å°‘é‡å®šæ—¶) â”‚     â”‚   æ¯Xç§’æ‰¹é‡å¤„ç† â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â–¼                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åè®®æ’ä»¶ç®¡ç†å™¨â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ PF4J åŠ¨æ€æ’ä»¶æ¡†æ¶         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æ„å»º **æ”¯æŒåŠ¨æ€æ’ä»¶åè®®åŠ è½½ + è®¾å¤‡é‡‡é›†è°ƒåº¦ + å¹¶å‘é«˜æ•ˆæ”¶é›†æ•°æ®** çš„å¹³å°ï¼Œæ¨èå¦‚ä¸‹ç»„åˆï¼š

ğŸ”§ **PF4J æ’ä»¶æœºåˆ¶** +
 ğŸš€ **Vert.xï¼ˆåè®®ç½‘ç»œå±‚ï¼‰** æˆ– **Reactorï¼ˆæ•°æ®æµå¤„ç†å±‚ï¼‰** +
 â±ï¸ **Quartz/Vert.x Schedulerï¼ˆä»»åŠ¡è°ƒåº¦ï¼‰** +
 ğŸ“¦ **Spring Boot ç®¡ç†å¹³å°ä¸»æœåŠ¡ï¼ˆç®¡ç†æ’ä»¶ã€æä¾›ç®¡ç†APIï¼‰**



### æ‰§è¡Œç”¨æˆ·è‡ªå®šä¹‰é€»è¾‘

| æŠ€æœ¯æ–¹æ¡ˆ                          | æ”¯æŒè¯­è¨€                             | ç‰¹ç‚¹                                  |
| --------------------------------- | ------------------------------------ | ------------------------------------- |
| **JSR-223 è„šæœ¬å¼•æ“**              | Groovyã€JavaScriptã€Pythonã€Ruby ç­‰  | æ ‡å‡†åŒ–æ¥å£ï¼Œæ˜“ç”¨                      |
| **Janino**                        | Javaï¼ˆå­é›†ï¼‰                         | å°†å­—ç¬¦ä¸²ç¼–è¯‘æˆ class å¹¶æ‰§è¡Œï¼Œæ€§èƒ½æé«˜ |
| **GraalVM**                       | JavaScript / Python / Ruby / WASM ç­‰ | æ›´å¼ºæ€§èƒ½å’Œå¤šè¯­è¨€æ”¯æŒ                  |
| **Java Compiler API (JDK tools)** | Java                                 | ç¼–è¯‘ä»£ç ä¸º classï¼Œä½†ä¸é€‚åˆé¢‘ç¹å°è„šæœ¬  |
| **Kotlin Scripting**              | Kotlin                               | æ›´ç°ä»£çš„è¯­è¨€ï¼ŒåµŒå…¥æ€§å¼º                |
| **Vert.x JS / Groovy**            | JS/Groovy è„šæœ¬ Verticle              | æ›´å¼ºåµŒå…¥èƒ½åŠ›å’Œå¼‚æ­¥èƒ½åŠ›                |



## Spring WebFlux åº”ç”¨åœºæ™¯

### 1. **é«˜å¹¶å‘ I/O å¯†é›†å‹æœåŠ¡**

- ç¤ºä¾‹ï¼šç½‘å…³ã€åå‘ä»£ç†ã€API èšåˆå™¨ã€è¾¹ç¼˜æœåŠ¡
- WebFlux é‡‡ç”¨ Netty/Undertow ç­‰éé˜»å¡æœåŠ¡å™¨ï¼Œèƒ½æ›´é«˜æ•ˆå¤„ç†æˆåƒä¸Šä¸‡ä¸ªå¹¶å‘è¿æ¥ã€‚

### 2. **éœ€è¦å“åº”å¼æµå¼å¤„ç†**

- ç¤ºä¾‹ï¼šå®æ—¶æ•°æ®æ¨é€ã€äº‹ä»¶é©±åŠ¨ç³»ç»Ÿã€æ•°æ®æµç®¡é“
- å¦‚ï¼š
  - SSEï¼ˆServer-Sent Eventsï¼‰
  - WebSocket å®æ—¶é€šä¿¡
  - æ¶ˆè´¹ Kafka ç­‰æµå¼æ•°æ®å¹¶é€æ¡å“åº”

### 3. **å¼‚æ­¥æœåŠ¡ç¼–æ’**

- æ¯”å¦‚å¤šä¸ªè¿œç¨‹ HTTP æœåŠ¡è°ƒç”¨ï¼Œéœ€è¦å¹¶å‘+ç»„åˆå“åº”
- ä½¿ç”¨ `Mono.zip()` / `Flux.merge()` ç­‰æ“ä½œç¬¦ç»„åˆå¤šä¸ªæœåŠ¡ç»“æœ

### 4. **å¾®æœåŠ¡æ¶æ„ä¸­è¾¹ç¼˜ç½‘å…³æœåŠ¡**

- å¸¸é…åˆ Spring Cloud Gateway ä½¿ç”¨ï¼Œç”¨äºï¼š
  - è¯·æ±‚è·¯ç”±
  - æƒé™æ ¡éªŒ
  - æ—¥å¿—ã€æµæ§ç­‰è¿‡æ»¤å™¨å¤„ç†
- WebFlux çš„éé˜»å¡ç‰¹æ€§èƒ½æœ‰æ•ˆæå‡ååå’Œèµ„æºåˆ©ç”¨



| æ¨¡å—                                  | æ˜¯å¦é€‚åˆ WebFlux               |
| ------------------------------------- | ------------------------------ |
| è®¾å¤‡æ•°æ®æ¥å…¥ç½‘å…³ï¼ˆMQTTã€TCP è½¬ RESTï¼‰ | âœ… é«˜å¹¶å‘ï¼ŒI/O å¤š               |
| ç®¡ç†åå°ï¼ˆè¡¨æ ¼ã€ç»Ÿè®¡ç­‰ï¼‰              | âŒ ä¸å¿…è¦ï¼ŒSpring MVC æ›´ç®€å•    |
| å®æ—¶æ¨é€å‘Šè­¦ / çŠ¶æ€å˜æ›´               | âœ… æ”¯æŒ SSE/WebSocket           |
| å†™å…¥ä¼ ç»Ÿæ•°æ®åº“ï¼ˆJDBCï¼‰                | âŒ ä¼šé˜»å¡ WebFluxï¼Œé™¤éæ¢ R2DBC |



| åŠŸèƒ½ç»´åº¦             | Vert.x / Reactor ä¼˜åŠ¿                  | è™šæ‹Ÿçº¿ç¨‹ç¼ºå¤±                               |
| -------------------- | -------------------------------------- | ------------------------------------------ |
| **äº‹ä»¶é©±åŠ¨æ¨¡å‹**     | å†…ç½®äº‹ä»¶å¾ªç¯ï¼Œæé«˜æ•ˆå¤„ç†äº‹ä»¶å’Œ IO      | éœ€è‡ªå·±è®¾è®¡äº‹ä»¶å¾ªç¯æˆ–åŒæ­¥é˜»å¡               |
| **èƒŒå‹æ”¯æŒ**         | å†…å»ºèƒŒå‹å’Œæµæ§ç­–ç•¥ï¼Œé˜²æ­¢èµ„æºè€—å°½       | æ— å†…ç½®èƒŒå‹ï¼Œéœ€è¦å¼€å‘è€…ç®¡ç†æµé‡             |
| **å¼‚æ­¥ API ä¸°å¯Œ**    | åºå¤§çš„å¼‚æ­¥åº“æ”¯æŒ TCP/HTTP/MQTT ç­‰åè®®  | ä¾èµ–é˜»å¡æˆ– CompletableFutureï¼Œéœ€è¦è‡ªå·±å°è£… |
| **èµ„æºå¤ç”¨**         | çº¿ç¨‹æ± ã€äº‹ä»¶å¾ªç¯å¤ç”¨ï¼Œè½»é‡é«˜æ•ˆ         | è™šæ‹Ÿçº¿ç¨‹æ•°è™½å¤šï¼Œä½†ä»æœ‰è°ƒåº¦æˆæœ¬             |
| **ç»„åˆç¼–æ’**         | å“åº”å¼é“¾å¼ç¼–ç¨‹ï¼Œçµæ´»ç»„åˆä»»åŠ¡å’Œé”™è¯¯å¤„ç† | åªèƒ½ç”¨ä¼ ç»ŸåŒæ­¥æˆ–å¼‚æ­¥å›è°ƒ                   |
| **æ’ä»¶åŠ¨æ€åŠ è½½æ”¯æŒ** | é€‚åˆåµŒå…¥å¼æ’ä»¶æœºåˆ¶ï¼ˆPF4Jç­‰ï¼‰           | æ— ç›´æ¥æ”¯æŒï¼Œéœ€è¦é¢å¤–è®¾è®¡                   |



| å·¥å…·                     | è¯´æ˜                         |
| ------------------------ | ---------------------------- |
| **jsPlumb**              | ç»å…¸æµç¨‹å›¾æ‹–æ‹½è¿æ¥åº“         |
| **JointJS**              | ä¸“ä¸šå›¾å½¢ç¼–è¾‘å™¨ï¼Œæ”¯æŒæµç¨‹å»ºæ¨¡ |
| **Drawflow**             | è½»é‡æ‹–æ‹½æµç¨‹å›¾æ„å»º           |
| **Diagram.js (Camunda)** | é€‚åˆ BPMN æµç¨‹ç¼–è¾‘           |



## æ–¹æ¡ˆä¸€ï¼šåŸºäº Vert.x

### æ ¸å¿ƒæ€è·¯

- æ¯ä¸ªåè®®æ’ä»¶å°è£…ä¸ºä¸€ä¸ª Verticleï¼ˆç»„ä»¶ï¼‰
- æ¯ä¸ªè®¾å¤‡çš„æ•°æ®é‡‡é›†é€šè¿‡ EventBus å®šæ—¶è°ƒåº¦
- æ‰€æœ‰é€»è¾‘åœ¨å°‘é‡ event loop çº¿ç¨‹ä¸­å¼‚æ­¥æ‰§è¡Œ

```java
public class ModbusVerticle extends AbstractVerticle {
    Map<String, DeviceConfig> devices = new ConcurrentHashMap<>();

    @Override
    public void start() {
        vertx.setPeriodic(1000, id -> {
            for (DeviceConfig dev : devices.values()) {
                fetchData(dev).onSuccess(data -> {
                    // å¤„ç†æ•°æ®
                });
            }
        });
    }

    Future<JsonObject> fetchData(DeviceConfig dev) {
        // è¿æ¥è®¾å¤‡ + è¯»å–æ•°æ®ï¼Œå¼‚æ­¥è¿”å›
    }

    public void addDevice(DeviceConfig dev) {
        devices.put(dev.deviceId, dev);
    }

    public void removeDevice(String id) {
        devices.remove(id);
    }
}

```

## æ–¹æ¡ˆäºŒï¼šåŸºäº Project Reactor

### æ ¸å¿ƒæ€è·¯

- ä½¿ç”¨ `Flux.interval()` æˆ– `Flux.generate()` å®šæ—¶é‡‡é›†
- æ¯ä¸ªåè®®æ’ä»¶å†…éƒ¨ç”Ÿæˆé‡‡é›†æµ
- é€šè¿‡ `flatMap()` å¹¶å‘å¤„ç†å¤šä¸ªè®¾å¤‡ï¼Œéé˜»å¡

```java
public class ModbusReactiveFetcher {
    Map<String, DeviceConfig> devices = new ConcurrentHashMap<>();

    public void start() {
        Flux.interval(Duration.ofSeconds(1))
            .flatMap(i -> Flux.fromIterable(devices.values()))
            .flatMap(this::fetchData)
            .subscribe(data -> {
                // å¤„ç†é‡‡é›†ç»“æœ
            });
    }

    public Mono<String> fetchData(DeviceConfig dev) {
        return Mono.fromCallable(() -> {
            // æ¨¡æ‹Ÿé‡‡é›†
            return "data-from-" + dev.deviceId;
        }).subscribeOn(Schedulers.boundedElastic());
    }
}

```

Akka â€”â€” Actor æ¨¡å‹ + å¼‚æ­¥æ¶ˆæ¯é©±åŠ¨:
	æ¯ä¸ªè®¾å¤‡æ˜ å°„ä¸ºä¸€ä¸ª Actorï¼ˆè½»é‡çº¿ç¨‹å•å…ƒï¼‰

	æ¯ä¸ª Actor ç®¡ç†ä¸€ä¸ªè®¾å¤‡çš„è¿æ¥ã€é‡è¯•ã€è§£ç ç­‰
	
	é‡‡é›†æŒ‡ä»¤ä½œä¸ºæ¶ˆæ¯å‘é€ç»™ Actorï¼Œçº¿ç¨‹å®‰å…¨ã€æ— é”ç¼–ç¨‹



| å·¥å…·                     | è¯´æ˜                         |
| ------------------------ | ---------------------------- |
| **jsPlumb**              | ç»å…¸æµç¨‹å›¾æ‹–æ‹½è¿æ¥åº“         |
| **JointJS**              | ä¸“ä¸šå›¾å½¢ç¼–è¾‘å™¨ï¼Œæ”¯æŒæµç¨‹å»ºæ¨¡ |
| **Drawflow**             | è½»é‡æ‹–æ‹½æµç¨‹å›¾æ„å»º           |
| **Diagram.js (Camunda)** | é€‚åˆ BPMN æµç¨‹ç¼–è¾‘           |



| ç»´åº¦           | Spring Cloud Functionï¼ˆé¢„å®šä¹‰ï¼‰ | åŠ¨æ€ç¼–è¯‘ï¼ˆè‡ªå®šä¹‰ï¼‰  |
| -------------- | ------------------------------- | ------------------- |
| æ¨èç¨‹åº¦       | âœ… æ›´æ˜“ç»´æŠ¤ã€æ€§èƒ½å¥½              | é€‚åˆé«˜çº§ç”¨æˆ·éœ€æ±‚    |
| å®ç°å¤æ‚åº¦     | â­â­                              | â­â­â­â­                |
| åŠ¨æ€æ€§         | âš ï¸ éœ€é…åˆå…ƒæ•°æ®ç»„è£…              | âœ… ç›´æ¥å†™ä»£ç é€»è¾‘    |
| å®‰å…¨æ€§         | âœ… é«˜                            | âŒ éœ€ sandbox æ§åˆ¶   |
| å¯è§†åŒ–æ‹–æ‹½ç»„åˆ | âœ… é€šè¿‡å…ƒæ•°æ®æ„å»º pipeline       | ğŸŸ¡ å¯è¡Œä½†éœ€ DSL ç¼–æ’ |

Spring Cloud Function solutionï¼š

- ç”¨æˆ·åœ¨ç•Œé¢ä¸ŠåŠ¨æ€é€‰æ‹©ã€æ‹–æ‹½ã€ç»„åˆä¸åŒçš„å‡½æ•°èŠ‚ç‚¹ï¼Œåå°æ ¹æ®ç”¨æˆ·é…ç½®å®æ—¶ç»„è£… pipeline å¹¶æ‰§è¡Œ

- æŠŠæ‰€æœ‰å•ä¸ªå‡½æ•°éƒ½æ³¨å†Œä¸º Spring Beanï¼ˆFunctionï¼‰

  ```java
  @Bean
  public Function<String, String> uppercaseName() { ... }
  
  @Bean
  public Function<String, String> addTimestamp() { ... }
  
  @Bean
  public Function<String, String> filterEmptyName() { ... }
  
  ```

- åˆ©ç”¨ `FunctionCatalog` åœ¨è¿è¡Œæ—¶æŸ¥æ‰¾å’Œç»„åˆå‡½æ•°

  ```java
  @Autowired
  private FunctionCatalog functionCatalog;
  
  public Function<String, String> buildPipeline(String[] funcNames) {
      if (funcNames == null || funcNames.length == 0) {
          return Function.identity();
      }
  
      Function<String, String> pipeline = functionCatalog.lookup(funcNames[0]);
      for (int i = 1; i < funcNames.length; i++) {
          Function<String, String> next = functionCatalog.lookup(funcNames[i]);
          pipeline = pipeline.andThen(next);
      }
      return pipeline;
  }
  
  ```

  - å‰ç«¯ä¼ é€’` ["filterEmptyName", "uppercaseName", "addTimestamp"]`
  - åç«¯æ ¹æ®é¡ºåºåŠ¨æ€ç”Ÿæˆç»„åˆå‡½æ•°æ‰§è¡Œ `Function<String, String> pipeline = buildPipeline(userSelectedFuncNames);
    String result = pipeline.apply(inputJson);`

- **Device Gateway.** Enables devices to connect to AWS IoT Core using standard protocols, including MQTT, HTTPS, and WebSockets. Communication is secured using X.509 certificates. The gateway acts as a central entry point for all device data and is a core messaging component of the platform.
- **Message Broker.** A high-throughput publish/subscribe (Pub/Sub) messaging system that facilitates data exchange between devices and the cloud. It supports MQTT directly or over WebSockets. Devices and cloud applications can publish messages to specific topics while others subscribe to receive them, enabling scalable and decoupled communication.
- **Rules Engine.** Connects incoming data from the message broker to other AWS services. Using SQL-like syntax, it allows users to filter, transform, and route messages to services such as S3, DynamoDB, and Lambda for processing, storage, or analytics.
- **Device Registry.** A control service that assigns and manages unique identities for connected devices. Each device is represented by a â€œthing objectâ€ that stores metadata and attributes. Certificates and policies define how a device authenticates and what actions it can perform. Templates help provision large numbers of devices efficiently.
- **Authentication and Authorization.** Supports mutual authentication and end-to-end encryption between devices and the cloud. Devices authenticate using X.509 certificates, and AWS IoT policies define permitted actions. Custom authorizers are also supported, including strategies like bearer token verification, JWT, and OAuth callouts.
- **Device Shadow.** This core data service creates a virtual representation of a deviceâ€™s state, known as a device shadow, which is stored as a JSON document in the cloud. Even when the device is offline, applications can access its last reported state or define a desired future state. Once the device reconnects, it automatically synchronizes with its shadow.

- **Rules Engine.** Connects incoming data from the message broker to other AWS services. Using SQL-like syntax, it allows users to filter, transform, and route messages to services such as S3, DynamoDB, and Lambda for processing, storage, or analytics.



The services and functions offered by an IoT platform can be divided into the following operational phases:

1. **Device connectivity and management.** This is the first phase of operation on an IoT platform. The platform provides mechanisms for securely registering and linking new IoT devices to the system. This may involve creating device IDs, generating authentication keys, and setting configuration options. The platform may use various communication protocols such as [MQTT](https://www.engineersgarage.com/what-is-mqtt-sparkplug-iiot/), CoAP, HTTP, Bluetooth, Zigbee, and LoRaWAN to establish communication with the device. It serves as a gateway that converts and transmits data from devices to the cloud. Once devices are connected and configured, the platform monitors their status and health remotely. It can also send commands and configuration updates to the devices.
2. **Data ingestion and processing.** Once connected, devices send data such as sensor readings, status updates, or requests to the platform. The platform receives this data through message brokers or APIs. The ingested data is then processed either in real time or in batches. Data processing may involve filtering, transforming, aggregating, and analyzing the data.
3. **Data storage.** The processed data is often stored in a platform-provided or integrated database, which may be a time-series, NoSQL, or relational database system. Stored data can be used for historical analysis, visualization, or triggering actions.â€™
4. **Data analytics and visualization.** Many platforms offer tools and services for analyzing stored data. These range from basic dashboards and visualizations to advanced machine learning and predictive analytics. The goal is to extract meaningful insights from device data.
5. **Application enablement.** The platform may provide APIs and SDKs that allow developers to build applications that interact with connected devices and processed data. These applications can be used for monitoring, control, automation, or user interaction.
6. **Security.** The platform may include features to secure device communication, authenticate devices, encrypt data in transit and at rest, and manage access control.