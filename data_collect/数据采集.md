可插拔采集协议
主平台架构使用标准模块化 + PF4J 插件系统
插件采集逻辑异步、线程安全，不影响平台主线程
插件 ≠ 单一设备采集器，而是一个协议适配器 + 多设备管理器

**驱动-调度器-任务模式**

```tex
在这种模式下，一个**“驱动”不再是简单的代码块，而是一个“协议管理器”或“协议工厂”**。它负责处理与某种协议（如 Modbus、MQTT）相关的底层通信，但本身不负责具体的采集逻辑。

驱动（Driver）：负责管理与底层硬件或网络的连接池，处理数据的发送和接收。例如，一个 Modbus TCP 驱动会维护与多个 Modbus 从站的连接，并处理读写请求的通信细节。

采集任务（Collection Task）：这是最小的工作单元。每个任务都与一个特定的设备、特定的数据点以及特定的采集频率相关联。例如，一个任务可能是：“每 5 秒读取设备 A 的温度传感器值”。

调度器（Scheduler）：这是整个系统的核心。它负责管理所有的采集任务，并根据每个任务设定的频率，在适当的时机将任务派发给相应的驱动。

```

**虚拟线程架构中的一个关键设计点：分离调度和执行。简单来说，你需要这两个线程池是因为它们扮演着不同的角色**

- 调度器 (ScheduledExecutorService) 的角色: 定时触发事件
- 虚拟线程执行器 (VirtualThreadPerTaskExecutor) 角色: 执行任务

 PF4J / Spring SPI



┌────────────┐        ┌────────────┐
│ Quartz 调度器│───▶  │采集任务事件│
└────┬───────┘        └────┬───────┘
     │                     │
     ▼                     ▼
┌────────────┐     ┌─────────────────┐
│ 精准调度设备│     │统一周期设备采集器│（Reactor/Vert.x）
│ (少量定时) │     │   每X秒批量处理 │
└────┬───────┘     └────────┬────────┘
     ▼                                ▼
┌────────────┐              ┌───────────────────────┐
│ 协议插件管理器│◀───────────│ PF4J 动态插件框架         │
└────────────┘              └───────────────────────┘

构建 **支持动态插件协议加载 + 设备采集调度 + 并发高效收集数据** 的平台，推荐如下组合：

🔧 **PF4J 插件机制** +
 🚀 **Vert.x（协议网络层）** 或 **Reactor（数据流处理层）** +
 ⏱️ **Quartz/Vert.x Scheduler（任务调度）** +
 📦 **Spring Boot 管理平台主服务（管理插件、提供管理API）**



### 执行用户自定义逻辑

| 技术方案                          | 支持语言                             | 特点                                  |
| --------------------------------- | ------------------------------------ | ------------------------------------- |
| **JSR-223 脚本引擎**              | Groovy、JavaScript、Python、Ruby 等  | 标准化接口，易用                      |
| **Janino**                        | Java（子集）                         | 将字符串编译成 class 并执行，性能极高 |
| **GraalVM**                       | JavaScript / Python / Ruby / WASM 等 | 更强性能和多语言支持                  |
| **Java Compiler API (JDK tools)** | Java                                 | 编译代码为 class，但不适合频繁小脚本  |
| **Kotlin Scripting**              | Kotlin                               | 更现代的语言，嵌入性强                |
| **Vert.x JS / Groovy**            | JS/Groovy 脚本 Verticle              | 更强嵌入能力和异步能力                |



## Spring WebFlux 应用场景

### 1. **高并发 I/O 密集型服务**

- 示例：网关、反向代理、API 聚合器、边缘服务
- WebFlux 采用 Netty/Undertow 等非阻塞服务器，能更高效处理成千上万个并发连接。

### 2. **需要响应式流式处理**

- 示例：实时数据推送、事件驱动系统、数据流管道
- 如：
  - SSE（Server-Sent Events）
  - WebSocket 实时通信
  - 消费 Kafka 等流式数据并逐条响应

### 3. **异步服务编排**

- 比如多个远程 HTTP 服务调用，需要并发+组合响应
- 使用 `Mono.zip()` / `Flux.merge()` 等操作符组合多个服务结果

### 4. **微服务架构中边缘网关服务**

- 常配合 Spring Cloud Gateway 使用，用于：
  - 请求路由
  - 权限校验
  - 日志、流控等过滤器处理
- WebFlux 的非阻塞特性能有效提升吞吐和资源利用



| 模块                                  | 是否适合 WebFlux               |
| ------------------------------------- | ------------------------------ |
| 设备数据接入网关（MQTT、TCP 转 REST） | ✅ 高并发，I/O 多               |
| 管理后台（表格、统计等）              | ❌ 不必要，Spring MVC 更简单    |
| 实时推送告警 / 状态变更               | ✅ 支持 SSE/WebSocket           |
| 写入传统数据库（JDBC）                | ❌ 会阻塞 WebFlux，除非换 R2DBC |



| 功能维度             | Vert.x / Reactor 优势                  | 虚拟线程缺失                               |
| -------------------- | -------------------------------------- | ------------------------------------------ |
| **事件驱动模型**     | 内置事件循环，极高效处理事件和 IO      | 需自己设计事件循环或同步阻塞               |
| **背压支持**         | 内建背压和流控策略，防止资源耗尽       | 无内置背压，需要开发者管理流量             |
| **异步 API 丰富**    | 庞大的异步库支持 TCP/HTTP/MQTT 等协议  | 依赖阻塞或 CompletableFuture，需要自己封装 |
| **资源复用**         | 线程池、事件循环复用，轻量高效         | 虚拟线程数虽多，但仍有调度成本             |
| **组合编排**         | 响应式链式编程，灵活组合任务和错误处理 | 只能用传统同步或异步回调                   |
| **插件动态加载支持** | 适合嵌入式插件机制（PF4J等）           | 无直接支持，需要额外设计                   |



| 工具                     | 说明                         |
| ------------------------ | ---------------------------- |
| **jsPlumb**              | 经典流程图拖拽连接库         |
| **JointJS**              | 专业图形编辑器，支持流程建模 |
| **Drawflow**             | 轻量拖拽流程图构建           |
| **Diagram.js (Camunda)** | 适合 BPMN 流程编辑           |



## 方案一：基于 Vert.x

### 核心思路

- 每个协议插件封装为一个 Verticle（组件）
- 每个设备的数据采集通过 EventBus 定时调度
- 所有逻辑在少量 event loop 线程中异步执行

```java
public class ModbusVerticle extends AbstractVerticle {
    Map<String, DeviceConfig> devices = new ConcurrentHashMap<>();

    @Override
    public void start() {
        vertx.setPeriodic(1000, id -> {
            for (DeviceConfig dev : devices.values()) {
                fetchData(dev).onSuccess(data -> {
                    // 处理数据
                });
            }
        });
    }

    Future<JsonObject> fetchData(DeviceConfig dev) {
        // 连接设备 + 读取数据，异步返回
    }

    public void addDevice(DeviceConfig dev) {
        devices.put(dev.deviceId, dev);
    }

    public void removeDevice(String id) {
        devices.remove(id);
    }
}

```

## 方案二：基于 Project Reactor

### 核心思路

- 使用 `Flux.interval()` 或 `Flux.generate()` 定时采集
- 每个协议插件内部生成采集流
- 通过 `flatMap()` 并发处理多个设备，非阻塞

```java
public class ModbusReactiveFetcher {
    Map<String, DeviceConfig> devices = new ConcurrentHashMap<>();

    public void start() {
        Flux.interval(Duration.ofSeconds(1))
            .flatMap(i -> Flux.fromIterable(devices.values()))
            .flatMap(this::fetchData)
            .subscribe(data -> {
                // 处理采集结果
            });
    }

    public Mono<String> fetchData(DeviceConfig dev) {
        return Mono.fromCallable(() -> {
            // 模拟采集
            return "data-from-" + dev.deviceId;
        }).subscribeOn(Schedulers.boundedElastic());
    }
}

```

Akka —— Actor 模型 + 异步消息驱动:
	每个设备映射为一个 Actor（轻量线程单元）

	每个 Actor 管理一个设备的连接、重试、解码等
	
	采集指令作为消息发送给 Actor，线程安全、无锁编程



| 工具                     | 说明                         |
| ------------------------ | ---------------------------- |
| **jsPlumb**              | 经典流程图拖拽连接库         |
| **JointJS**              | 专业图形编辑器，支持流程建模 |
| **Drawflow**             | 轻量拖拽流程图构建           |
| **Diagram.js (Camunda)** | 适合 BPMN 流程编辑           |



| 维度           | Spring Cloud Function（预定义） | 动态编译（自定义）  |
| -------------- | ------------------------------- | ------------------- |
| 推荐程度       | ✅ 更易维护、性能好              | 适合高级用户需求    |
| 实现复杂度     | ⭐⭐                              | ⭐⭐⭐⭐                |
| 动态性         | ⚠️ 需配合元数据组装              | ✅ 直接写代码逻辑    |
| 安全性         | ✅ 高                            | ❌ 需 sandbox 控制   |
| 可视化拖拽组合 | ✅ 通过元数据构建 pipeline       | 🟡 可行但需 DSL 编排 |

Spring Cloud Function solution：

- 用户在界面上动态选择、拖拽、组合不同的函数节点，后台根据用户配置实时组装 pipeline 并执行

- 把所有单个函数都注册为 Spring Bean（Function）

  ```java
  @Bean
  public Function<String, String> uppercaseName() { ... }
  
  @Bean
  public Function<String, String> addTimestamp() { ... }
  
  @Bean
  public Function<String, String> filterEmptyName() { ... }
  
  ```

- 利用 `FunctionCatalog` 在运行时查找和组合函数

  ```java
  @Autowired
  private FunctionCatalog functionCatalog;
  
  public Function<String, String> buildPipeline(String[] funcNames) {
      if (funcNames == null || funcNames.length == 0) {
          return Function.identity();
      }
  
      Function<String, String> pipeline = functionCatalog.lookup(funcNames[0]);
      for (int i = 1; i < funcNames.length; i++) {
          Function<String, String> next = functionCatalog.lookup(funcNames[i]);
          pipeline = pipeline.andThen(next);
      }
      return pipeline;
  }
  
  ```

  - 前端传递` ["filterEmptyName", "uppercaseName", "addTimestamp"]`
  - 后端根据顺序动态生成组合函数执行 `Function<String, String> pipeline = buildPipeline(userSelectedFuncNames);
    String result = pipeline.apply(inputJson);`

- **Device Gateway.** Enables devices to connect to AWS IoT Core using standard protocols, including MQTT, HTTPS, and WebSockets. Communication is secured using X.509 certificates. The gateway acts as a central entry point for all device data and is a core messaging component of the platform.
- **Message Broker.** A high-throughput publish/subscribe (Pub/Sub) messaging system that facilitates data exchange between devices and the cloud. It supports MQTT directly or over WebSockets. Devices and cloud applications can publish messages to specific topics while others subscribe to receive them, enabling scalable and decoupled communication.
- **Rules Engine.** Connects incoming data from the message broker to other AWS services. Using SQL-like syntax, it allows users to filter, transform, and route messages to services such as S3, DynamoDB, and Lambda for processing, storage, or analytics.
- **Device Registry.** A control service that assigns and manages unique identities for connected devices. Each device is represented by a “thing object” that stores metadata and attributes. Certificates and policies define how a device authenticates and what actions it can perform. Templates help provision large numbers of devices efficiently.
- **Authentication and Authorization.** Supports mutual authentication and end-to-end encryption between devices and the cloud. Devices authenticate using X.509 certificates, and AWS IoT policies define permitted actions. Custom authorizers are also supported, including strategies like bearer token verification, JWT, and OAuth callouts.
- **Device Shadow.** This core data service creates a virtual representation of a device’s state, known as a device shadow, which is stored as a JSON document in the cloud. Even when the device is offline, applications can access its last reported state or define a desired future state. Once the device reconnects, it automatically synchronizes with its shadow.

- **Rules Engine.** Connects incoming data from the message broker to other AWS services. Using SQL-like syntax, it allows users to filter, transform, and route messages to services such as S3, DynamoDB, and Lambda for processing, storage, or analytics.



The services and functions offered by an IoT platform can be divided into the following operational phases:

1. **Device connectivity and management.** This is the first phase of operation on an IoT platform. The platform provides mechanisms for securely registering and linking new IoT devices to the system. This may involve creating device IDs, generating authentication keys, and setting configuration options. The platform may use various communication protocols such as [MQTT](https://www.engineersgarage.com/what-is-mqtt-sparkplug-iiot/), CoAP, HTTP, Bluetooth, Zigbee, and LoRaWAN to establish communication with the device. It serves as a gateway that converts and transmits data from devices to the cloud. Once devices are connected and configured, the platform monitors their status and health remotely. It can also send commands and configuration updates to the devices.
2. **Data ingestion and processing.** Once connected, devices send data such as sensor readings, status updates, or requests to the platform. The platform receives this data through message brokers or APIs. The ingested data is then processed either in real time or in batches. Data processing may involve filtering, transforming, aggregating, and analyzing the data.
3. **Data storage.** The processed data is often stored in a platform-provided or integrated database, which may be a time-series, NoSQL, or relational database system. Stored data can be used for historical analysis, visualization, or triggering actions.’
4. **Data analytics and visualization.** Many platforms offer tools and services for analyzing stored data. These range from basic dashboards and visualizations to advanced machine learning and predictive analytics. The goal is to extract meaningful insights from device data.
5. **Application enablement.** The platform may provide APIs and SDKs that allow developers to build applications that interact with connected devices and processed data. These applications can be used for monitoring, control, automation, or user interaction.
6. **Security.** The platform may include features to secure device communication, authenticate devices, encrypt data in transit and at rest, and manage access control.