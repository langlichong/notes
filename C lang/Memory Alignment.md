- 省钱秘诀： 写结构体时，习惯性地按照成员长度从大到小排列（例如先写 double, 再写 int, 最后写 char），通常能获得最紧凑的内存布局，且自动满足所有对齐要求
<img width="1103" height="807" alt="image" src="https://github.com/user-attachments/assets/4e427d21-6465-4e75-af7c-510ebde4069c" />

- __attribute__((packed)): 反编译器内存对齐
  - 网络协议包 (Communication Protocols) `当你定义一个网络协议头（例如 IP 头部）或者自定义总线协议时，每个字节的位置必须是死死锁定的。如果编译器私自加了填充字节，发送方的结构体和接收方的物理报文就对不齐了，导致数据解析错误`
  - 读写外部硬件寄存器 `有的外部传感器（通过 SPI/I2C 读写）返回一串连续的数据流。你通常会定义一个结构体，然后把读取到的 Buffer 直接强转（Cast）成结构体指针。如果不加 packed，结构体里的成员就会错位`
  - 文件格式解析 `解析 BMP 图片、WAV 音频头等具有固定字节排布的文件格式时`
