Tips: c的man手册更像是规范的定义，而非教程，现代编程语言的文档基本都包含了语法与示例或教程，对C可以在一下几个地方查找教程或示例
	- cppreference.com (C 部分): cppreference.com/w/c
	- devdocs.io 中 c部分
	- cheat.sh: curl cheat.sh/c/strcmp
	-  beej.us/guide/

1. 字符数组本身不记录长度，依赖编译器在末尾填充结束符ascii 0: \0
2. gcc: gnu compiler collection , 分前、中、后端三部分
   - 可以使用 zig cc 替换 gcc: zig cc 提供了优秀的编译速度与跨平台编译能力(一个-target参数即可)
   - 现代编程语言基本都是自举的，是一种特殊的递归，本质是数学中的不动点（Fixed Point）**原理
   -自举Bootstrapping: 普通的函数递归是在运行时发生的；而自举是在语言版本演进的过程中发生的。它不是在同一个点上循环，而是一个螺旋上升的过程：用版本 N 的编译器去编译版本 N+1 的源代码，从而产生版本 N+1 的编译器
   - 在工程实现上，它依赖于一个被称为 “引导（Bootstrapping）” 的过程(借腹借腹生子（The Seed）)
   - 自举意义: 吃自己的狗粮（Dogfooding）：如果一个编译器开发者自己都不愿意用这种语言写大型程序（编译器本身就是极其复杂的程序），那怎么证明这门语言好用？自举是语言成熟度的终极测试
   - 自举之后，语言的进化确实只需要修改自己的源码，但你必须总是用“上一代编译器”作为梯子，去构建“下一代”
   - 克莱尼递归定理（Kleene's Recursion Theorem): 对于任何可计算的程序转换，都存在一个“不动点”程序，其行为与转换后的程序一致。
3. scanf: 不推荐使用，很难控制(如遇到空 或 回车回自动停止读取、每次读取后不会自动清空缓冲区，导致下次读取很难处理等), 推荐使用 fgets 或 getline 然后使用 sscanf 进行处理
	- man 3 scanf 可以看到man手册的解释
4. stdbool.h: c99引入，引入bool, true, false , 本质是使用的宏进行定义： true 为 1， false 为 0，非零即真
5. 程序内存layout: 栈、堆、.text 、.rodata 、.bss(未初始化)、已初始化数据段.data (Data Segment / Initialized Data Segment)(静态、全局)）
	- 如果你定义 int arr[10000] = {1, 2, 3};，这个数组会被放在 .data 段，可执行文件必须实打实地存储这些数字，文件会变大
	- 如果你定义 int arr[10000];，它会被放在 .bss 段。在磁盘上的文件中，它不占用空间，只记录一个“我需要 40,000 字节”的标记。
	- bss分配给程序前OS会对其进行初始化，避免‘‘残留信息泄露’’
	- 既然 BSS 是操作系统清零的，那 .data 段里那些 int a = 10; 的初始值是谁填进去的呢？: 程序加载器（Loader）直接从文件中拷贝
6. 数组的在栈中布局: 一次分配，其数据增长方向与栈从高地址向低地址正好相反，数组的增长是始终向高地址进行(即a[n]地址低于 a[n+1])
	- 栈向下增长而数组向上增长，导致了著名的**栈溢出（Stack Buffer Overflow）**漏洞: 数组写入是向高地址方向进行的，溢出的数据会向“上”覆盖掉栈帧中的关键信息，比如函数的返回地址或其他局部变量
	- 编译器一般会自动插入一些检测机制，一旦数组增长覆盖了栈中其他已分配地址就报错
	- 为何不改: x86 架构（Intel/AMD）统治了个人电脑和服务器市场几十年，它的 PUSH 指令在硬件层面就是减少栈指针（ESP/RSP）。要改这个，意味着要重写全球所有的编译器、操作系统内核和调试工具。
	- 其他语言，它们大多继承了这一底层事实，但在表现形式上做了“封装”: 边界检查（Bounds Checking）。如果索引越界，直接抛出异常（如 ArrayIndexOutOfBoundsException），根本不给你覆盖栈空间的机会
	- Stack Canaries (金丝雀/栈保护)针：在缓冲区和返回地址之间插一个随机数，如果发现这个数变了，程序直接自毁，防止返回地址被篡改 --- 以阻止如缓冲区溢出攻击（Buffer Overflow Attack）
	- 缓冲区溢出攻击（Buffer Overflow Attack）
7. 字符串字面量不允许修改: 编译器为了优化内存空间，对其使用了池化技术，不是修改做不到而是不允许, char name[] = "tom"，实际先将tom放入字符串池中，然后拷贝一份给name即放到栈上
8. c中的赋值`=`不仅是语句而且是表达式，即本身会返回右值，即可以利用其进行链式赋值(求值时候从右向左进行),甚至在while 、for等语句中(如常见的stream的读入后赋值并判断是否结束)
9. 方法执行过程主要依赖: RIP, RSP, RBP寄存器的协同
10. 执行流控制: if-else , while , do-while , for , case(只能针对数字类型，一个语句检查了变量的多种取值，用于优化if语句，提高可读性)
11. 内存布局(layout)： 栈、堆、全局量、常量、代码段
		
		- 二进制layout
		段名称	       存储内容	              磁盘占用			初始化者							备注
		Code (.text)	机器指令	                很大				编译器生成						只读
		Data (.data)	已初始化的全局变量	        很大				加载器从文件拷贝					存储非 0 值
		BSS (.bss)	    未初始化的全局变量	        极小（仅标记）		操作系统/加载器清零				效率最高
		Heap	       动态分配 (malloc)	        无	程序员手动	运行时产生
		Stack	       局部变量					无				编译器移动指针						运行时产生，内容随机
		
	- c中任意一个声明的变量，如 int a;, 未初始化时候使用a会读取到一个garbage value, 例外情况: 声明了从未使用，同时开启了编译优化则可能该变量会被彻底删除不会被分配内存
	- .data 只存值。变量名（符号）存在专门的 .symtab 和 .strtab 段里。如果是生产环境，这些名字通常会被删掉，只留下纯粹的内存操作指令
	- 对于 CPU 来说，变量名只是为了算出地址偏移量的脚手架,
		- 变量名去哪了？如果你非要找变量名，它们被存到了另一个被称为 符号表（Symbol Table）（linux elf中一般包含 .symtab (Symbol Table) 与 .strtab (String Table)）
		- strtab: 因为变量名长短不一，为了节省空间，所有的名字（如 "a", "my_global_variable", "func_name"）都被连续地存在这个“字符串表”里，中间用 \0 分开
		- 符号表也是二进制文件中的一个独立区域（Section）
		- 符号表的内容：它像一张地图，记录着 a -> 偏移地址 8，b -> 偏移地址 12
	- 生成的二进制文件（硬盘上的文件）里的 .data 段，其实连地址都没有，只有纯粹的值
		- int a = 10; int b = 20; 则 .data 段在文件里的内容就是：0A 00 00 00 14 00 00 00（假设是 4 字节小端序）
		- 注意：这里没有任何“地址”信息，也没有“a”或“b”的名字。它只是按顺序摆放的一串数字
	- 地址是什么时候出现的？
		- 当程序被加载到内存时，操作系统会根据文件的“段表”信息，把这一串数字搬到内存的某个位置（比如 0x401000）
		- 此时，原本在文件偏移为 0 的 10，其内存地址就变成了 0x401000。地址是“算”出来的，而不是“存”在数据段里的
	- 全局或static的变量: 分配在BSS segment, 同时内存自动初始化为零(C 语言规定，BSS 段的内容在程序启动前由操作系统或运行时环境清零。即便你没手动赋值，它也是确定的 0)
	- data段使用流程: 
		- 编译阶段：当你写 int a = 10; 时，编译器会在生成的**二进制文件（.exe 或 .elf）**的 .data 部分，专门划出 4 个字节，里面直接写死二进制的 00 00 00 0A（即十六进制的 10）
		- 加载阶段：当操作系统运行你的程序时，它执行的是一种类似于 “内存镜像拷贝” 的操作(操作系统在内存里申请一块地, 它把硬盘文件里 .data 段的那块内容（包含那个 10），原封不动地“拍”到内存里)
	- 段表: Section/Segment Header Table
		- 没有这张表，操作系统打开你的程序时，看到的只是黑压压的一堆 0 和 1，它根本不知道哪一段是指令、哪一段是数据、哪一段该放进内存的什么位置	
	- Section vs Segment (进阶小知识)
		- 在 Linux 的 ELF 文件里，其实有两套相似的概念：
			- Section (节)：这是编译时的概念。编译器把代码分成 .text、.data、.bss、.symtab 等几十个“节”，方便管理。
			- Segment (段)：这是运行时的概念。为了提高效率，操作系统加载时会把权限相同的“节”打包在一起处理。比如把 .text 和 .rodata 合并成一个大的“只读段（Segment）”
			- 所以你会发现，链接器（Linker）的工作之一，就是把零散的 Section 按照规则合并成 操作系统喜欢的 Segment，并写入程序头表（Program Header Table）
	- 链接器的“剧本”：为什么它敢预言地址？
		- 在编译的最后一个阶段——**链接（Linking）**时，链接器（Linker）就像是一个城市规划师。
		- 链接器并不是在真实的地皮（物理内存）上盖房子，而是在一张**标准化的、空无一物的“虚拟地图”**上画图纸
		- 链接器假设：“每个程序运行的时候，都觉得自己拥有整个世界（比如从 0x0000 到 0xFFFF 的全部地址）。”
		- 因为它假设每个人拥有的“地图”都长得一样，所以它敢提前规定：.text 段永远从地图上的 0x400000 开始，.data 段紧跟其后。
		- 这个提前写在文件里的地址，就是编译时确定的虚拟地址（Preferred Base Address）
		- 现代变数: ASLR (地址空间布局随机化)：为了防止黑客精准预测返回地址（就是我们之前聊的攻击方式），操作系统在加载程序时，会故意不在预定的 0x400000 加载，而是随机选一个偏移量（比如往后挪 100 字节）
		- 就像你买了一本《宜家家具安装手册》，手册上说“螺丝 A 安装在支架 B 的左上角”; 手册并不知道你会在哪个城市、哪个房间组装这把椅子，但它规定了零件之间的确切位置关系。二进制文件里的虚拟地址，就是家具零件在“盒子里的位置规范”。
		- 程序中取地址符号&: 拿到的是逻辑地址或成为虚拟地址
12. function
	- main中调用函数前如果之前没有函数原型声明，则编译器会认为当前执行的函数默认返回值为int，会隐式给一个原型(prototype),若main后面出现了真实定义部分往往会冲突(conflicting types)
		- 本质是历史发展中c执行是顺序扫描的，不会像java、rust之类的做提升 Hoisting 或扫描
		- 引出c中工程化做法: 头文件(.h)
	- c中函数调用参数是按值传递(经典的交互两个变量的值)： 可以分析函数执行过程中栈帧中变量分配与函数退出过程得到结果
12. pointer: 避免副本和共享数据
		- NULL 是一个非常基础但又充满了设计细节的宏。它代表一个空指针常量，即“不指向任何有效对象的指针(它本质上是数值 0。但为了增强可读性和类型安全，通常将其强制转换为 void * 类型的指针)
		- 在 C 中：NULL 是 (void *)0
		- 使用指针时候的一个通用问题： 指针只是开始或一个地址，实际应该读取多长呢？这就是数据类型的作用即指针+数据类型即可确定实际的操作范围（字符数组或字符串有点例外，其末尾会添加一个结束字符，所以一般不需要知道长度）
		- 获取变量地址: &variable-name 
		- 数组退化为指针: 函数参数为数组时，编译器会将其退化到指针形式，如 void print_str(char msg[]) -> void print_str(char *msg)  // 数组退化成了指针
		- 数组的名称不会被分配任何存储空间（数组的内容（元素）会被分配存储空间，但“数组名”本身并不像普通变量那样占用额外的存储空间来存放地址），所以数组的名称不能指向其他地方（定义一个指针变量时会分配存储空间）
		- 数组名是一个“常量符号”，而不是“变量”，本质上它只是一个右值常量
		- 编译器仅在出现数组名称的地方把它替换成数组的起始地址（数组名在大多数表达式中会退化为指向首元素的指针）
		- 打印地址: fprint("%p", &variable-name)
		- 读取指针(变量地址)所指向(保存)的值: *pointer-variable-name (因有时指针被称为引用，所以取值即解引用)
		- sizeof: 不是函数而是一个运算符不是函数(在 C 语言中，你不能把一个类型名称（如 int, double）传递给函数。函数只能接受“值”或“指针)
			- 区别: 编译器会把运算符编译为一串指令；而当程序调用函数时，会跳到一段独立的代码中执行
		- c中指针只有地址值，没有长度等其他信息，一般解决方案是手动传参定义长度、哨兵值(如字符串结束符\0)、自定义结构体封装长度与指针本身
		- 其他高级语言中的胖指针就是为解决C 语言这种“纯地址指针”信息过少的问题而设计的
		- 在 C 或 Rust 的原始数组中，长度是类型的一部分: [i32; 5] 和 [i32; 500] 是完全不同的类型
		- pointer本质是一个数字，所以可以对其进行加减法运算
		- 指针的加法不是简单的数字加法，而是“步长”加法
		- 对数组而言:  drinks[i] 和 *(drinks + i) 是等价的，
		- 索引的本质是指针算术运算，所以数组从0开始
		- 指针只是地址，为什么指针变量有类型？为什么不能用一种通用类型的变量保存所有的指针？这样就能调整指针算术运算
		- 在 C 语言标准中，数组下标运算符 [] 本质上是一个指针算术的语法糖: 对于任何数组（或指针）a 和索引 i，表达式 a[i] 的定义始终等价于： *(a + i), i[a] 等价于 *(i + a),交换律后 a[i]=i[a]
		- 在 C 语言思维中，[] 只是一个算术运算符: 址 和 偏移量 相加，然后去那个地方取值: 3[letters] 并不是 3 + letters 的简写，而是 *(3 + letters) 的简写
		- 指向字符串字面值的指针变量不能用来修改字符串的内容(字符串字面量在可执行文件的 .rodata 段，这部分区域在程序运行时由操作系统标记为只读)（若要修改一般使用字符数组）
		- 一般声明字符串字面量时候配合const： const char *s = "xxxx"
		- 使用字符串字面量初始化字符数组时会将字符串字面量拷贝一份放大栈上
13. string
	- string.h: 如比较、搜索、复制、切割
	- c中字符串就是字符数组
	- 指针的数组: 常用创建字符串字面量列表 或 数组的数组 
	- size_t: count of bytes, 是sizeof返回值
	
14. 过滤器程序与标准输入输出:
    - 标准输入/输出是每个程序自带的三个“槽位”或“接口”，它们属于“进程（Program in execution）”，但由“操作系统”来统一实现和管理
	- 标准输入/输出它是程序的“三元组”： 每当你运行一个程序（在 Linux 或 Windows 中），操作系统在启动这个程序的一瞬间，会给这个程序自动分配 3 个文件描述符（File Descriptors）
	- 每一个运行中的程序（进程）都有自己独立的一套 0, 1, 2(可以查阅 man 3 stdin 说明)： 编号 0 (stdin)：标准输入， 编号 1 (stdout)：标准输出， 编号 2 (stderr)：标准错误
	- 虽然 0, 1, 2 是属于程序的，但这些槽位到底接在什么地方，由操作系统说了
	- 默认状态：操作系统把你的 stdin(0) 接到键盘，把你的 stdout(1) 接到屏幕， 标准错误会默认发送到显示器
	- 使用 < 重定向时：你告诉操作系统：“嘿，这次启动这个程序时，把它的 stdin(0) 槽位接到 data.txt 文件上，别接键盘。
	- 使用 | 管道时：你告诉操作系统：“把程序 A 的 stdout(1) 槽位，直接接到程序 B 的 stdin(0) 槽位上。
	- 2>&1: 此处&是一个转义，它告诉 Shell：“后面那个 1 不是一个文件名，而是一个文件描述符编号（写 2 > 1，Shell 会创建一个名字叫 "1" 的普通文本文件，把报错写进去）
	- ./geo2json > output.log 2>&1 此处 2与output.log 中间为何没有 && 或  & ？？直觉上会觉得应该用一个“逻辑连接符”（如 & 或 &&）把它们连起来
		-  Shell 的设计中，不需要连接符号
		- & 或 && 是用来连接两个独立的完整命令的。比如 cmd1 && cmd2
		- > output.log 和 2>&1 并不是命令，它们被统称为**“重定向操作符”**（Redirection Operators），Shell 的语法规则是：多个重定向设置直接并列书写
		- Shell 规定，你可以在一个命令后面挂载任意多个重定向，它们只需要空格分开即可： 就像是给命令 ./geo2json 配置的“参数”或“修饰配件”。你可以理解为这些重定向符号是直接挂载在主命令后面的
		- 执行逻辑：它发生在“程序运行之前
		
	- 注意: 在shell中重定向标准输入、输出时候打头的必须是个动作:  ./geo2json < gpsdata.csv > output.json ,错误写法:   gpsdata.csv > ./geo2json > output.json
	- unix中:  过滤器程序特征
		- 从标准输入（stdin）读取数据：它不关心数据是从文件读的、从其他程序传来的，还是人手敲的
		- 对数据进行转换处理：比如把 CSV 格式转成 JSON 格式
		- 向标准输出（stdout）写入数据：它不关心输出是显示在屏幕上，还是保存到了文件
	- `<`: 重定向标准输入
	- `>`: 重定向标准输出 
	- ./geo2json < gpsdata.csv > output.json: 从gpsdata.csv读取内容，处理后输出到 output.json 
	- 在 C/Unix 哲学中，有一个重要的原则：stdout 应该只带纯粹的数据，而 stderr 用来带“除了数据以外的一切”
		- 假设你的 geo2json 程序正在工作
		- stdout (1)：应该只输出最终生成的 JSON 字符串。这样别人才能用 > 把它保存到文件，或者用 | 传给下一个程序
		- stderr (2)：应该输出类似 正在加载第 10 行...、完成 50%、发现一个不合规的坐标，已跳过 等信息
		- stderr (2)：应该输出类似 正在加载第 10 行...、完成 50%、发现一个不合规的坐标，已跳过 等信息（很多写得好的外部程序，会故意把所有的“人机交互信息”都发送到 stderr）
		- 在资深开发者眼中：stdout：是机器读的（给下个程序用的） ，stderr：是人读的（给开发者看的日志）
	- 重定向时候一般会使用fprintf, printf底层也是fprintf(stdout,...)
	- 文件描述符数字（如 2）与重定向符号（> 或 >>）之间绝对不能有空格: 正确写法：2>err.log 或 2> err.log
	- tips: 在java中Process#getInputStream 获取的却是外部程序的stdout (以java自己为中心的视角)
	
15. pipeline(管道)
	- pipe(|): 连接一个进程的输出与另一个进程的输入(而重定向只能用于连接同一个程序的stdin， stdout, stderr )，操作系统会处理管道的细节
	- ./bermuda <asset/spooky.csv | ./geo2json >asset/output.json  等效写法 (./bermuda | ./geo2json) <assert/spooky.csv >output.json
	- `<` 会把文件内容发送到流水线中第一个进程的标准输入， `>` 会捕获流水线中最后一个进程的标准输出
	- 除了每个进程启动时OS分配的3个标准stream, 可以通过fopen创建新数据流(每条数据流用一个指向文件的指针来表示)
	
16. 数据流
	- fopen: 打开一个stream ，返回FILE类型指针,一定要fclose 
	- C语言层面没有限制fopen可以打开的流的数量，而OS有限制(ulimit -n)
	
17. main 参数/选项:
	- main(int argc, char *argv[]): main() 函数能以字符串数组的形式读取命令行参数(字符指针数组)
	- main(int argc, char *argv[]): 一个是参数的计数，另一个是指针（指向参数字符串）数组
	- argv: Argument Vector, 一个存储字符串指针的数组。每个指针都指向你从命令行输入的一个单词。
	- argc 是 Argument Count 的缩写，表示参数的个数。它总是至少为 1（因为程序名本身占第一个位置）
	- 在 C 语言中，复杂的定义遵循“右向左”原则
	- 从“右向左”读法char *argv[]: argv[]: argv 是一个数组, *argv[]: 这个数组里存放的东西是“指针”, char *argv[]: 这些指针指向的类型是 char
	- argv[0]: 第一个参数是要运行的程序的名字, 即 第一个命令行参数其实是argv[1]
	- getopt(<unistd.h>)： 命令行选项函数, 每次调用则返回下一个参数,支持选项合并( -d now -t 合并为 -td now )
	- getopt() 可以极大地简化你的解析工作。它会自动帮你区分哪个是选项（Option），哪个是参数（Argument），并处理诸如 -abc（合并选项）的情况
	- optarg: 如果选项后面跟着一个参数（如 -f file.txt），解析后 optarg 就会指向 "file.txt"。
	- optind: 下一个待处理元素的索引
	- opterr: 设为 0 可以关闭 getopt 自动向屏幕打印错误信息。
	- optopt: 当出现未知选项或缺少参数时，保存该选项字符
	- 停止标志 --：如果用户命令行里写了 --，getopt 会立即停止解析选项，把后面所有的内容都当作普通参数
	- 参数与选项: 选项以`-`开始 ，对于负数参数为避免与选项混淆，一般使用 `--`隔开， e.g.  set_temper-ature -c -- -4
	
18. 类型
	- 为了适应硬件，C语言在不同的操作系统与处理器上使用不同的数据类型大小（C语言没有指定数据类型的具体大小）
	- 计算机的单次能处理的bit数基本决定了基本数据类型的长度(32位机器则int是32bit)
	- limits.h 、float.h 等中定义了最大、最小范围
	- c中若一个函数在使用时没有提前声明，编译器一般会默认其类型为int(即所有函数必须在main之前有声明或声明加定义)
	- 声明与定义分离（在某些情况下如递归，总有一个会出现在另一个前面，如果声明与定义总是一起出现，无法解决该问题）
	- 函数声明: 声明只是一个函数签名：一条包含函数名、形参类型与返回类型的记录(一旦声明了函数，编译器就不需要假设，完全可以先调用函数，再定义函数)
	- 头文件: 甚至可以把这些声明拿到代码外，放到一个头文件中
	- 引入头文件: `<>` 与 `""`, 尖括号，就会到标准库代码所在目录查找头文件,引号表示以相对路径查找头文件
	- 预处理: 查找 - 拷贝-替换
	- 类Unix操作系统中，标准库的头文件通常保存在 /usr/local/include 、 /usr/include 这些地方

19. 编译 
	- 预处理：修改代码、 
	- 编译：转换成汇编代码、
	- 汇编：生成目标代码(将这些符号代码汇编成机器代码或目标代码,即CPU内部电路执行的二进制代码,编译器会为每个源文件生成一个目标代码,即以单个源文件为编译单元)
	- 链接：放在一起
	- 共享变量： 为了防止两个源文件中的同名变量相互干扰，变量的作用域仅限于某个文件内。如果你想共享变量，就应该在头文件中声明，并在变量名前加上extern关键字
	- gcc -c *.c: 只编译到目标文件，不做链接（每一个 .c 文件(编译单元)在编译成目标文件（.o 或 .obj）时，内部都会包含一个专门的符号表,链接器在工作时候需要查找该表）
	- 目标文件的结构:  Linux 或 macOS 上，你可以使用 nm 或 objdump 命令来查看一个 .o 文件的符号表
		- 符号表是目标文件的“护照”和“合同”，没有它，独立的编译单元就无法联合起来组成一个庞大的程序
		- .text: 机器指令
		- .data: 已初始化的全局变量
		- .bss: 未初始化的全局变量
		- .symtab, 
		- .strtab: 字符串表（存储符号具体的名称，如 "main", "foo"）
		- .rel.text(重定位信息（告诉链接器哪些地址需要被修正）) 
	- gcc *.o -o launch: 链接所有目标文件,生成可执行文件
	- 链接器（ld）的工作其实就是**“合并与对账”**
		- 它把所有输入的 .o 文件里的 .text 段拼在一起，.data 段也拼在一起
		- 它收集所有文件的 .symtab（符号表）
		- 对账：它拿着文件 A 的“需求项”，去查文件 B、C、D 的“供应项”
		- 一旦匹配成功，它就会更新最终生成的代码，把临时的“占位地址”替换为真实的“合并后地址”
		- 链接后：最终的可执行文件中依然有一张巨大的合并后的符号表
		- Strip 操作：为了减小可执行文件体积，发布正式版时通常会执行 strip 命令。它会删掉所有不影响运行的符号（主要是调试符号和局部符号），但对于动态链接所需的符号，仍必须保留
20. make
	- make 会检查源文件和目标文件的时间戳，如果目标文件过期， make 就会重新编译它
	- make 需要知道文件之间的依赖关系(生成目标需要用哪些文件)、生成方法(生成该文件时要用哪些指令),这构成了一条规则
	- makefile: 所有目标、依赖项和生成方法的细节信息需要保存在一个叫makefile或Makefile的文件中
	- autoconf可以用来生成makefile

21. structured data type - struct 
	- struct fish{ ...}
	- 结构字段访问: dot符号
	- 指定初始化器” (Designated Initializers: .成员名 = 值): struct fish x = {.color = "Gold", .name = "Goldfish", .weight = 1};
	- 结构嵌套
	- 用typedef为结构命名： struct s_fish {...}fish, 即struct有两个名字，一个是s_fish 结构名 ， 另一个是类型名字 fish， 可以只写类型名而省略结构名
	- 匿名结构: typedef struct {...} Alias;
	- 对于一个已经定义好的具体 struct 类型，其大小在编译完成后就是固定（涉及内存对齐问题，如留白导致从sizeof看到的大小与肉眼观测结果不一致）
	- 结构体的大小在特定编译环境下是固定的，但他等于“成员大小之和 + 编译器为了效率塞进去的填充字节”
	- 计算机总是希望数据能对齐字边界（word boundary），即跨越单次读取的宽度后导致需要多次读取数据(需要多条指令完成本来只需要一条指令的工作)
	- 代码里觉得内存是一个一个字节连续排列的，对 CPU 硬件来说，它每次从内存拿数据都是一箱一箱拿的（这一箱的大小就是“字长”）
	- 在 32 位机器上，每箱是 4 字节， 内存读取只能从 0, 4, 8, 12 ... 这种对齐的地址开始
	- 自然对齐（Natural Alignment): 起始地址必须是自身长度的倍数（每个变量都希望自己的起始地址能被自己的长度整除)
	- 只要一个变量（比如 4 字节的 int）存放在能被其长度 4 整除的地址上，数学上就能完美保证它永远不会横跨任何更大的动力边界
	- char (1字节)：可以在任何地址开始（0, 1, 2, 3...）, short (2字节)：只能在偶数地址开始（0, 2, 4...），int (4字节)：只能在能被 4 整除的地址开始（0, 4, 8...）
	- 规则是：成员之间的 Padding（确实看相邻）; 但整个结构体的大小，必须是其“最顶尖成员（对齐要求最高的那位）”的整数倍
	- 当为结构赋值时，计算机会复制结构的值
	- 结构指针：更新结构。如果想让函数更新结构变量，就不能把结构作为参数传递，因为这样做仅仅是将数据的副本复制给了函数
		- 箭头表达式： 访问结构体指针中成员， e.g. t->age

22. union 联合 、enum、bit-field
	- 所有成员共享同一块内存, 这块地同一时间只能存放一个成员的值。联合体总大小 = 最大成员的大小
	- typedef union{...}
	- 没有标签（Tagged Union）：union 本身不知道目前存的是哪种类型。通常开发者会配合一个 enum (在联合中保存各种可能的值，但保存以后，就无法知道它的类型)
	- 如果你有一个对象，它在不同情况下会存储不同类型的数据，但绝对不会同时存储它们，用 union 可以极大节省空间
	- Type Punning(绕过类型解析原始内存): 强行摘掉编译器的眼镜(编译器戴上的一副“眼镜”，决定了它如何去解读这些 0 和 1)，用一种类型的逻辑去读取另一种类型的数据块
	- union 所有成员共用起始地址,存入 A 类型，取出 B 类型
	- 类型转换 (Type Conversion)：编译器会生成额外的 CPU 指令去修改数据格式
	- 绕过解析 (Type Punning)：编译器不生成任何转换指令，只是简单地把那块地址上的位传给后续逻辑
	- Bit-field(位域): 是 C 语言中一种及其精细的内存管理工具; 它允许你在结构体中以“位”（bit）为单位来指定成员占用的空间，而不是以字节（byte）为单位
		- 当你需要操作底层硬件、处理网络包协议，或者在极度内存受限的场景下“斤斤计较”时，位域是无可替代的工具
		- 成员变量名后面加上 : 数字，这个数字就代表占用的 bit 数:  unsigned int is_connected : 1;  // 只占 1 位，表示 0 或 1  unsigned int error_code   : 3;  // 占 3 位，表示 0 到 7
		- 不能对位域成员使用 & 运算符。因为电脑内存寻址的最小单位是字节，CPU 无法单独定位到某个 bit 的物理地址
		- 类型限制： 位域通常只能是 int、unsigned int 或 signed int。使用 char 或 bool 取决于编译器的具体实现
		- 不可移植性（Endianness）： 这是最严重的坑。位域在内存里是从低位向高位排还是从高位向低位排，C 标准没有规定，完全取决于 CPU 架构（大端/小端）和编译器实现
		- 与 Union 结合: 驱动开发中，为了既能按位操作，又能按整体赋值
		
23. dynamic data structure and memory allocate 
	- ADT(抽象数据结构: 可以用来保存很多不同类型的数据): linked-list 
	- 栈: 栈是存储器用来保存局部变量的区域。数据保存在局部变量中，一旦离开函数，变量就会消失
	- 堆: 堆上的数据不会自动清除, 常用于保存无法确定大小的动态增长的内容
	- malloc(memory allocation): 告诉malloc() 需要多少存储器(字节,一般需要sizeof确定大小),	其会向OS申请对应大小内存，并会返回一个指针，指向堆上新分配的空间
	- malloc返回void* 类型的指针
	- free: 释放malloc分配堆内存
	- valgrind：valgrind 通过伪造 malloc() 可以监控分配在堆上的数据
	
24. 函数与指针、可变参数
	- C语言中，函数名也是指针变量： 函数名是指向函数的指针
	- 定义一个函数 void func() {} 时: 
		- 编译器层面：它只是在符号表中记录了 func 这个名字对应代码段（Text Segment）的起始地址
		- 内存层面：并没有额外分配 4 或 8 个字节的空间来存储这个地址（除非你显式定义了一个 void (*p)() = func;）
		- 行为层面：函数名 func 本身就是一个常量地址，类似于数组名
	- 在 C 语言中，除了作为 sizeof 和 & 运算符的操作数外，函数名会自动转换成指向该函数的指针
		- 同一个函数f: f 、&f、*f、甚至无限解引用 *****f 其值都是一样的 
		- C 语言并没有在后台偷偷为你创建一个同名的 void (*func)() 变量。它只是规定：当你使用 func 这个名字时，如果没有特殊操作，就把它当作它的地址来用
		- 若没有简化则每次调用函数都得写成 (*func)()，而现在你只需要写 func()
	- 函数名和数组名在 C 语言中都遵循类似的“退化”（Decay）规则
		- 数组名：退化指向该数组首元素的指针
		- 函数名：退化指向该函数代码起始位置的指针
		- 不同点：退化后的行为差异
			- 数组名：不退化。sizeof(arr) 返回的是整个数组占据的字节数
			- 函数名：不退化（但不能直接求大小）。sizeof(func) 在标准 C 中是非法的（或者说没有定义大小），因为函数不是数据对象
	- C 语言的视角：函数是一个“黑盒地址”，根本不知道函数的长度，当你通过函数指针调用函数时，C 语言只负责做两件事
		- 把参数按照约定的规则放进寄存器或栈里
		- 执行一个 JMP（跳转或调用）指令，将 CPU 的程序计数器（IP）指向那个退化后的首地址
	- 真正决定函数结束的是“指令”，而不是“长度”: RET 指令
		- 终止指令（RET）：在汇编层面，函数的最后通常是一条返回指令（如 x86 的 ret
		- 终止指令（RET）：在汇编层面，函数的最后通常是一条返回指令（如 x86 的 
	- 函数不是像 int arr[5] 那样的数据对象，它是一段逻辑流。逻辑流只有“终点”，没有“长度”的必然概念
	- 函数指针: 返回类型 (* 指针变量 )( 参数类型 ) e.g.  char** (*names_fn)(char*,int)
		- 标准库中的 qsort其入参就有一个函数指针 : man 3 qsort 
	- 函数指针数组
	- 高阶函数
	- 可变参数函数
		- stdarg.h
		- 可变参数将保存在va_list中（va_start()、va_ arg()和va_end()控制va_ list）
		- C标准库中有一组宏（macro）可以帮助你建立自己的可变参数函数

25. 静态库、动态库
	- 共享头文件: .h 
		- 把头文件保存在标准目录中，如/usr/local/include 
		- 在include语句中使用完整路径名（如果你想把头文件放在其他地方）
		- 你可以告诉编译器去哪里找头文件: gcc -I选项
	- 创建目标文件存档，就可以一次告诉编译器一批目标文件: .a 文件
		- 一个存档中包含多个目标文件
		- 用ar命令创建存档
		- .a文件名都是libXXX.a的形式
		- 存档是静态库（static library），所以要以lib开头
		- 库存档名应以 lib 开头，以 .a 结尾
	- 动态库 
		- 动态库在运行时链接程序（man ld 查阅链接器细节）
		- 动态库在不同机器上名字不同(.so, .dll, .dylib)
		- 若动态库不在标准目录(/lib, /usr/lib, /usr/local/lib)则需设置PATH变量和LD_LIBRARY_PATH变量
		- /etc/ld.so.conf、/etc/ld.so.conf.d 、ldconfig 命令
		- GOT (Global Offset Table) 和 PLT (Procedure Linkage Table) 是 Linux 动态链接系统的核心
		- PLT 是跳板（代码），GOT 是地址簿（数据）
		- PLT（Procedure Linkage Table）
		- 编译成带 PIC 的目标文件（.o) : gcc -fPIC -c my_lib.c -o my_lib.o
		- 链接成共享库: gcc -shared -o libmy.so my_lib.o
		
26. 进程与系统调用
	- 内核: 主管3样东西: 进程、存储器、硬件
	- 系统调用是操作系统内核中的函数
	- 系统调用出错时通常会返回－1，但不是绝对的
	- system() 函数是在代码中运行其他程序的捷径（操作系统必须解释命令字符串，然后决定运行哪些程序和怎样运行）
	- exec(): 明确地告诉操作系统你想运行哪个程序，exec() 函数通过运行其他程序来替换当前进程，新程序启动后PID和老程序一样
		- 如果成功运行，则exec()后面的语句不会执行，若失败则会执行exec()语句后面代码，依次可以判定exec是否成功
		- exec系列主要分2大类: 一类是使用参数数组，一类使用列表方式传参
	- errno 变量是定义在errno.h中的全局变量，可以用string.h中的 strerror() 的函数查询标准错误消息: puts(strerror(errno))
	- 系 统 调 用 在 出 错 的 同 时 将errno变量设为错误码
	- fork()克隆进程: 想在启动另一个进程的同时让原进程继续运行下去
		-  fork() 函数向子进程返回0，向父进程返回非零值，其返回类型为 pid_t
		- fork()+exec()创建子进程
		- fork() 是一个“调用一次，返回两次”的特殊函数（即父进程中那句 fork()调用语句也会出现在子进程中,子进程一出生就在 fork() 返回的那一刻，函数返回了 0，赋值给了 pid）
		- 虽然子进程的代码里有 pid_t pid = fork(); 这行字，但子进程并没有执行“再 fork 一次”的动作，它只是经历了“赋值”的那个尾声
		- 子进程是 “半路杀出来的”。它继承了父进程运行到那一行的状态，然后从 fork() 的返回点开始接着往后跑
		- 克隆发生的时间点：就在 fork() 调用的那一刹那， 克隆的内容：包括当前的变量值、内存状态，以及你当前运行到了代码的哪一行（指令指针）
		- 子进程拥有父进程的内存状态，但它们在 fork() 之后就是两个独立的个体了。为了实现这一点，操作系统使用了一个非常天才的技术：写时拷贝（Copy-on-Write, 简称 COW）
		- 刚 fork 完时：父进程和子进程其实共用同一块物理内存。系统把这块内存标为“只读”， 当你要“读”时：父子进程都从同一个地方读，相安无事，速度飞快， 当你尝试“改”时（核心）会产生缺页中断并拷贝需要修改的数据到新空间，并调整该页的权限
		- 现代操作系统的内存管理、权限控制以及“写时拷贝”（COW）机制，都是以**页（Page）**为基本单位的
		- 父子进程是平等的。谁想改数据，谁就得承担“拷贝”带来的那一点点性能消耗（“拷贝税”）
		- 如果子进程 fork() 出来之后，立刻去执行 exec()（加载一个新程序，比如运行 ls），那么子进程会完全抛弃父进程的内存
	```text 	
		当我们写 pid_t pid = fork(); 时，这个语句其实可以拆解为三步：
		准备调用：程序准备进入内核执行 fork。
		内核克隆：操作系统在内核里完成进程克隆。
		返回赋值：将 fork 的结果返回，并赋值给名为 pid 的变量。
		关键点就在第 2 步和第 3 步之间：

		当父进程执行到第 2 步时，子进程诞生了。
		子进程诞生时的状态：它的指令指针正好指在“即将从 fork 函数返回”的位置。
		所以，子进程不需要重新去“运行” fork() 那个动作（否则它又会生出孙子进程，陷入无限循环），它直接从 第 3 步（返回并赋值） 开始运行
	```

27. IPC 
	- 进程描述符表:（通常指文件描述符表 File Descriptor Table）是由内核直接管理的
		- 可以读取 /proc/self/fd/ 目录。该目录下的每一个文件名，就是一个当前进程打开的文件描述符（FD）
		- 谈论“描述符表”时，在内核（以 Linux 为例）里它对应的是进程控制块 task_struct 中的一个指针
	- /proc/self/fd 这个路径中，self 是 Linux 操作系统提供的虚拟符号链接（Symbolic Link）
		- self 是一个动态解析的链接。内核在处理任何对 /proc/self 的访问请求时，都会自动将其替换为发起请求的那个进程的 PID 文件夹
		- self代表当前正在访问这个路径的进程自己
		-  C 代码里打开自己的描述符表时直接访问 /proc/self/fd 即可，省去了查询和拼接 PID 的麻烦
	- 标准输入/输出/错误在描述符表中的位置是固定的,其编号为: 0,1,2
	- dup2(old,new)(复制数据流): 修改已经在文件描述符表注册过数据流
	- 每打开一个文件，操作系统都会在描述符表中新注册一项(fileno()可根据FILE返回描述符号)
	- waitpid(): 等子进程结束以后才返回
	- exit()可以快速结束程序, exit()不会失败，因此也就没有返回值
	- /dev/tty 是一个非常特殊的设备文件，它被形象地称为**“当前进程的控制终端（Controlling Terminal）”**
		- 只要你在代码里打开 /dev/tty，内核都会自动将其指向你当前正在使用的那个终端
		- /dev/tty 永远指向屏幕（只要进程有控制终端）
		- 打开 /dev/tty 文件，就可以把数据直接发送到终端(FILE *tty = fopen("/dev/tty", "w");)
		- 输入密码：像 sudo 或 ssh 这样的程序，在询问密码时，为了确保提示语出现在屏幕上且密码不通过管道泄露，它们通常会直接打开 /dev/tty 进行读写
		- 后台进程：如果一个进程是脱离终端运行的（比如守护进程 Daemon），它可能没有控制终端。此时尝试打开 /dev/tty 会失败并返回 ENXIO 错误
	- 用宏WEXITSTATUS()取出pid_status 前8位用于判定进程退出状态
	- 实时读取子进程的输出 管道: 
		- 用管道连接进程,管道两侧的命令是父子关系
		- 管道只能单向通信
		- 程序中需要使用pipe()创建管道，它创建两条相连的数据流，并把它们加到描述符表中
		- pipe()并返回了两个描述符： fd[1]用来向管道写数据， fd[0] 用来从管道读数据
		- 通常用 pipe() 创建的管道都不是文件
		- 创 建 基 于 文 件的管道，它们通常叫有名管道或FIFO（First In First Out，先进先出）文件（mkfifo()）
		-  子进程结束时，管道会关闭, fgets()将收到EOF
	- 信号
		- 信号是 Unix 系统中一种极其轻量级的异步通知机制,它是内核（Kernel）用来告诉进程“发生了某件事”的一种方式
		- 信号是软件层面的模拟，而中断(Interrupt)是硬件层面的机制
		- 信号是一条短消息，即一个整型值, 信号常被称为“软件中断”,信号可以在进程运行的任何时刻突然到达，进程必须停下手中的活去处理它（除非你忽略或屏蔽了它）
		- 每个信号都对应一个信号处理器函数(ctrl + c -> exit())
		- sigaction: sigaction 是一个结构体，它有一个函数指针;  sigaction告诉操作系统进程收到某个信号时应该调用哪个函数
		- sigaction 包装的函数就叫处理器
		- signal(SIGINT, my_handler): 该方式比较简陋
		-  kill 默认会向进程发送 SIGTERM 信号，你也可以用它发送其他信号
		- 某些信号进程是不能忽略的，必须处理（kill －KILL <PID>：一定会终止进程）
		- raise函数发送信号: 可以向自己发送信号
		- SIGALRM：闹钟信号（Alarm Clock Signal），它的作用很简单：当一个预先设定的定时器（Timer）到期时，内核会向进程发送这个信号(配合alarm函数)
		- 一个进程只能有一个闹钟。如果你在第一个闹钟还没响时又调了一次 alarm(5)，之前的闹钟会被取消，重新开始计时，alarm(0) 可以关闭闹钟
		- alarm() 的精度通常是 秒 级。如果你需要更精细的时间（微秒级），应该使用 setitimer() 或更现代的 timer_create()
		- HRTimer 的出现，使得内核不再依赖于固定频率的“滴答”，而是直接利用硬件的高精度计数器（如 CPU 的 TSC 寄存器），底层使用红黑树 (Red-Black Tree)
			- nanosleep()：当你调用这个函数休眠几百纳秒时，内核底层就是通过 HRTimer 挂起你的进程
28. net & socket 
	- 数据流: 文件、标准输入、标准输出、套接字
	- 套接字不是传统意义上的数据流,socket是双向的
	- sys/socket.h
	- arpa/inet.h
	- netdb.h
	- BLAB: 用套接字与客户端程序通信前，服务器需要历经四个阶段：绑定（Bind）、监听（Listen）、接受（Accept）和开始（Begin），首字母缩写为BLAB
	- send,recv
	- AF 与 BF流派之争
	- htonl，htons, bind, listen, accept
	- TCP TIME_WAIT(只有主动发起断开连接的一方（Active Closer）会进入 TIME_WAIT 状态) 可能导致port在一定时间内不可重用，可通过 SO_REUSEADDR 允许重用
	- 域名套接字: getaddrinfo

29. POSIX线程
