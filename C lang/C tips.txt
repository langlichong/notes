Tips: c的man手册更像是规范的定义，而非教程，现代编程语言的文档基本都包含了语法与示例或教程，对C可以在一下几个地方查找教程或示例
	- cppreference.com (C 部分): cppreference.com/w/c
	- devdocs.io 中 c部分
	- cheat.sh: curl cheat.sh/c/strcmp
	-  beej.us/guide/

1. 字符数组本身不记录长度，依赖编译器在末尾填充结束符ascii 0: \0
2. gcc: gnu compiler collection , 分前、中、后端三部分
   - 可以使用 zig cc 替换 gcc: zig cc 提供了优秀的编译速度与跨平台编译能力(一个-target参数即可)
   - 现代编程语言基本都是自举的，是一种特殊的递归，本质是数学中的不动点（Fixed Point）**原理
   -自举Bootstrapping: 普通的函数递归是在运行时发生的；而自举是在语言版本演进的过程中发生的。它不是在同一个点上循环，而是一个螺旋上升的过程：用版本 N 的编译器去编译版本 N+1 的源代码，从而产生版本 N+1 的编译器
   - 在工程实现上，它依赖于一个被称为 “引导（Bootstrapping）” 的过程(借腹借腹生子（The Seed）)
   - 自举意义: 吃自己的狗粮（Dogfooding）：如果一个编译器开发者自己都不愿意用这种语言写大型程序（编译器本身就是极其复杂的程序），那怎么证明这门语言好用？自举是语言成熟度的终极测试
   - 自举之后，语言的进化确实只需要修改自己的源码，但你必须总是用“上一代编译器”作为梯子，去构建“下一代”
   - 克莱尼递归定理（Kleene's Recursion Theorem): 对于任何可计算的程序转换，都存在一个“不动点”程序，其行为与转换后的程序一致。
3. scanf: 不推荐使用，很难控制(如遇到空 或 回车回自动停止读取、每次读取后不会自动清空缓冲区，导致下次读取很难处理等), 推荐使用 fgets 或 getline 然后使用 sscanf 进行处理
	- man 3 scanf 可以看到man手册的解释
4. stdbool.h: c99引入，引入bool, true, false , 本质是使用的宏进行定义： true 为 1， false 为 0，非零即真
5. 程序内存layout: 栈、堆、.text 、.rodata 、.bss(未初始化)、已初始化数据段.data (Data Segment / Initialized Data Segment)(静态、全局)）
	- 如果你定义 int arr[10000] = {1, 2, 3};，这个数组会被放在 .data 段，可执行文件必须实打实地存储这些数字，文件会变大
	- 如果你定义 int arr[10000];，它会被放在 .bss 段。在磁盘上的文件中，它不占用空间，只记录一个“我需要 40,000 字节”的标记。
	- bss分配给程序前OS会对其进行初始化，避免‘‘残留信息泄露’’
	- 既然 BSS 是操作系统清零的，那 .data 段里那些 int a = 10; 的初始值是谁填进去的呢？: 程序加载器（Loader）直接从文件中拷贝
6. 数组的在栈中布局: 一次分配，其数据增长方向与栈从高地址向低地址正好相反，数组的增长是始终向高地址进行(即a[n]地址低于 a[n+1])
	- 栈向下增长而数组向上增长，导致了著名的**栈溢出（Stack Buffer Overflow）**漏洞: 数组写入是向高地址方向进行的，溢出的数据会向“上”覆盖掉栈帧中的关键信息，比如函数的返回地址或其他局部变量
	- 编译器一般会自动插入一些检测机制，一旦数组增长覆盖了栈中其他已分配地址就报错
	- 为何不改: x86 架构（Intel/AMD）统治了个人电脑和服务器市场几十年，它的 PUSH 指令在硬件层面就是减少栈指针（ESP/RSP）。要改这个，意味着要重写全球所有的编译器、操作系统内核和调试工具。
	- 其他语言，它们大多继承了这一底层事实，但在表现形式上做了“封装”: 边界检查（Bounds Checking）。如果索引越界，直接抛出异常（如 ArrayIndexOutOfBoundsException），根本不给你覆盖栈空间的机会
	- Stack Canaries (金丝雀/栈保护)针：在缓冲区和返回地址之间插一个随机数，如果发现这个数变了，程序直接自毁，防止返回地址被篡改 --- 以阻止如缓冲区溢出攻击（Buffer Overflow Attack）
	- 缓冲区溢出攻击（Buffer Overflow Attack）
7. 字符串字面量不允许修改: 编译器为了优化内存空间，对其使用了池化技术，不是修改做不到而是不允许, char name[] = "tom"，实际先将tom放入字符串池中，然后拷贝一份给name即放到栈上
8. c中的赋值`=`不仅是语句而且是表达式，即本身会返回右值，即可以利用其进行链式赋值(求值时候从右向左进行),甚至在while 、for等语句中(如常见的stream的读入后赋值并判断是否结束)
9. 方法执行过程主要依赖: RIP, RSP, RBP寄存器的协同
10. 执行流控制: if-else , while , do-while , for , case(只能针对数字类型，一个语句检查了变量的多种取值，用于优化if语句，提高可读性)
11. 内存布局(layout)： 栈、堆、全局量、常量、代码段
		
		- 二进制layout
		段名称	       存储内容	              磁盘占用			初始化者							备注
		Code (.text)	机器指令	                很大				编译器生成						只读
		Data (.data)	已初始化的全局变量	        很大				加载器从文件拷贝					存储非 0 值
		BSS (.bss)	    未初始化的全局变量	        极小（仅标记）		操作系统/加载器清零				效率最高
		Heap	       动态分配 (malloc)	        无	程序员手动	运行时产生
		Stack	       局部变量					无				编译器移动指针						运行时产生，内容随机
		
	- c中任意一个声明的变量，如 int a;, 未初始化时候使用a会读取到一个garbage value, 例外情况: 声明了从未使用，同时开启了编译优化则可能该变量会被彻底删除不会被分配内存
	- .data 只存值。变量名（符号）存在专门的 .symtab 和 .strtab 段里。如果是生产环境，这些名字通常会被删掉，只留下纯粹的内存操作指令
	- 对于 CPU 来说，变量名只是为了算出地址偏移量的脚手架,
		- 变量名去哪了？如果你非要找变量名，它们被存到了另一个被称为 符号表（Symbol Table）（linux elf中一般包含 .symtab (Symbol Table) 与 .strtab (String Table)）
		- strtab: 因为变量名长短不一，为了节省空间，所有的名字（如 "a", "my_global_variable", "func_name"）都被连续地存在这个“字符串表”里，中间用 \0 分开
		- 符号表也是二进制文件中的一个独立区域（Section）
		- 符号表的内容：它像一张地图，记录着 a -> 偏移地址 8，b -> 偏移地址 12
	- 生成的二进制文件（硬盘上的文件）里的 .data 段，其实连地址都没有，只有纯粹的值
		- int a = 10; int b = 20; 则 .data 段在文件里的内容就是：0A 00 00 00 14 00 00 00（假设是 4 字节小端序）
		- 注意：这里没有任何“地址”信息，也没有“a”或“b”的名字。它只是按顺序摆放的一串数字
	- 地址是什么时候出现的？
		- 当程序被加载到内存时，操作系统会根据文件的“段表”信息，把这一串数字搬到内存的某个位置（比如 0x401000）
		- 此时，原本在文件偏移为 0 的 10，其内存地址就变成了 0x401000。地址是“算”出来的，而不是“存”在数据段里的
	- 全局或static的变量: 分配在BSS segment, 同时内存自动初始化为零(C 语言规定，BSS 段的内容在程序启动前由操作系统或运行时环境清零。即便你没手动赋值，它也是确定的 0)
	- data段使用流程: 
		- 编译阶段：当你写 int a = 10; 时，编译器会在生成的**二进制文件（.exe 或 .elf）**的 .data 部分，专门划出 4 个字节，里面直接写死二进制的 00 00 00 0A（即十六进制的 10）
		- 加载阶段：当操作系统运行你的程序时，它执行的是一种类似于 “内存镜像拷贝” 的操作(操作系统在内存里申请一块地, 它把硬盘文件里 .data 段的那块内容（包含那个 10），原封不动地“拍”到内存里)
	- 段表: Section/Segment Header Table
		- 没有这张表，操作系统打开你的程序时，看到的只是黑压压的一堆 0 和 1，它根本不知道哪一段是指令、哪一段是数据、哪一段该放进内存的什么位置	
	- Section vs Segment (进阶小知识)
		- 在 Linux 的 ELF 文件里，其实有两套相似的概念：
			- Section (节)：这是编译时的概念。编译器把代码分成 .text、.data、.bss、.symtab 等几十个“节”，方便管理。
			- Segment (段)：这是运行时的概念。为了提高效率，操作系统加载时会把权限相同的“节”打包在一起处理。比如把 .text 和 .rodata 合并成一个大的“只读段（Segment）”
			- 所以你会发现，链接器（Linker）的工作之一，就是把零散的 Section 按照规则合并成 操作系统喜欢的 Segment，并写入程序头表（Program Header Table）
	- 链接器的“剧本”：为什么它敢预言地址？
		- 在编译的最后一个阶段——**链接（Linking）**时，链接器（Linker）就像是一个城市规划师。
		- 链接器并不是在真实的地皮（物理内存）上盖房子，而是在一张**标准化的、空无一物的“虚拟地图”**上画图纸
		- 链接器假设：“每个程序运行的时候，都觉得自己拥有整个世界（比如从 0x0000 到 0xFFFF 的全部地址）。”
		- 因为它假设每个人拥有的“地图”都长得一样，所以它敢提前规定：.text 段永远从地图上的 0x400000 开始，.data 段紧跟其后。
		- 这个提前写在文件里的地址，就是编译时确定的虚拟地址（Preferred Base Address）
		- 现代变数: ASLR (地址空间布局随机化)：为了防止黑客精准预测返回地址（就是我们之前聊的攻击方式），操作系统在加载程序时，会故意不在预定的 0x400000 加载，而是随机选一个偏移量（比如往后挪 100 字节）
		- 就像你买了一本《宜家家具安装手册》，手册上说“螺丝 A 安装在支架 B 的左上角”; 手册并不知道你会在哪个城市、哪个房间组装这把椅子，但它规定了零件之间的确切位置关系。二进制文件里的虚拟地址，就是家具零件在“盒子里的位置规范”。
		- 程序中取地址符号&: 拿到的是逻辑地址或成为虚拟地址
12. function
	- main中调用函数前如果之前没有函数原型声明，则编译器会认为当前执行的函数默认返回值为int，会隐式给一个原型(prototype),若main后面出现了真实定义部分往往会冲突(conflicting types)
		- 本质是历史发展中c执行是顺序扫描的，不会像java、rust之类的做提升 Hoisting 或扫描
		- 引出c中工程化做法: 头文件(.h)
	- c中函数调用参数是按值传递(经典的交互两个变量的值)： 可以分析函数执行过程中栈帧中变量分配与函数退出过程得到结果
12. pointer: 避免副本和共享数据
		- 使用指针时候的一个通用问题： 指针只是开始或一个地址，实际应该读取多长呢？这就是数据类型的作用即指针+数据类型即可确定实际的操作范围（字符数组或字符串有点例外，其末尾会添加一个结束字符，所以一般不需要知道长度）
		- 获取变量地址: &variable-name 
		- 数组退化为指针: 函数参数为数组时，编译器会将其退化到指针形式，如 void print_str(char msg[]) -> void print_str(char *msg)  // 数组退化成了指针
		- 数组的名称不会被分配任何存储空间（数组的内容（元素）会被分配存储空间，但“数组名”本身并不像普通变量那样占用额外的存储空间来存放地址），所以数组的名称不能指向其他地方（定义一个指针变量时会分配存储空间）
		- 数组名是一个“常量符号”，而不是“变量”，本质上它只是一个右值常量
		- 编译器仅在出现数组名称的地方把它替换成数组的起始地址（数组名在大多数表达式中会退化为指向首元素的指针）
		- 打印地址: fprint("%p", &variable-name)
		- 读取指针(变量地址)所指向(保存)的值: *pointer-variable-name (因有时指针被称为引用，所以取值即解引用)
		- sizeof: 不是函数而是一个运算符不是函数(在 C 语言中，你不能把一个类型名称（如 int, double）传递给函数。函数只能接受“值”或“指针)
			- 区别: 编译器会把运算符编译为一串指令；而当程序调用函数时，会跳到一段独立的代码中执行
		- c中指针只有地址值，没有长度等其他信息，一般解决方案是手动传参定义长度、哨兵值(如字符串结束符\0)、自定义结构体封装长度与指针本身
		- 其他高级语言中的胖指针就是为解决C 语言这种“纯地址指针”信息过少的问题而设计的
		- 在 C 或 Rust 的原始数组中，长度是类型的一部分: [i32; 5] 和 [i32; 500] 是完全不同的类型
		- pointer本质是一个数字，所以可以对其进行加减法运算
		- 指针的加法不是简单的数字加法，而是“步长”加法
		- 对数组而言:  drinks[i] 和 *(drinks + i) 是等价的，
		- 索引的本质是指针算术运算，所以数组从0开始
		- 指针只是地址，为什么指针变量有类型？为什么不能用一种通用类型的变量保存所有的指针？这样就能调整指针算术运算
		- 在 C 语言标准中，数组下标运算符 [] 本质上是一个指针算术的语法糖: 对于任何数组（或指针）a 和索引 i，表达式 a[i] 的定义始终等价于： *(a + i), i[a] 等价于 *(i + a),交换律后 a[i]=i[a]
		- 在 C 语言思维中，[] 只是一个算术运算符: 址 和 偏移量 相加，然后去那个地方取值: 3[letters] 并不是 3 + letters 的简写，而是 *(3 + letters) 的简写
		- 指向字符串字面值的指针变量不能用来修改字符串的内容(字符串字面量在可执行文件的 .rodata 段，这部分区域在程序运行时由操作系统标记为只读)（若要修改一般使用字符数组）
		- 一般声明字符串字面量时候配合const： const char *s = "xxxx"
		- 使用字符串字面量初始化字符数组时会将字符串字面量拷贝一份放大栈上
13. string
	- string.h: 如比较、搜索、复制、切割
	- c中字符串就是字符数组
	- 指针的数组: 常用创建字符串字面量列表 或 数组的数组 
	- size_t: count of bytes, 是sizeof返回值
	
14. 过滤器程序与标准输入输出:
    - 标准输入/输出是每个程序自带的三个“槽位”或“接口”，它们属于“进程（Program in execution）”，但由“操作系统”来统一实现和管理
	- 标准输入/输出它是程序的“三元组”： 每当你运行一个程序（在 Linux 或 Windows 中），操作系统在启动这个程序的一瞬间，会给这个程序自动分配 3 个文件描述符（File Descriptors）
	- 每一个运行中的程序（进程）都有自己独立的一套 0, 1, 2(可以查阅 man 3 stdin 说明)： 编号 0 (stdin)：标准输入， 编号 1 (stdout)：标准输出， 编号 2 (stderr)：标准错误
	- 虽然 0, 1, 2 是属于程序的，但这些槽位到底接在什么地方，由操作系统说了
	- 默认状态：操作系统把你的 stdin(0) 接到键盘，把你的 stdout(1) 接到屏幕， 标准错误会默认发送到显示器
	- 使用 < 重定向时：你告诉操作系统：“嘿，这次启动这个程序时，把它的 stdin(0) 槽位接到 data.txt 文件上，别接键盘。
	- 使用 | 管道时：你告诉操作系统：“把程序 A 的 stdout(1) 槽位，直接接到程序 B 的 stdin(0) 槽位上。
	- 2>&1: 此处&是一个转义，它告诉 Shell：“后面那个 1 不是一个文件名，而是一个文件描述符编号（写 2 > 1，Shell 会创建一个名字叫 "1" 的普通文本文件，把报错写进去）
	- ./geo2json > output.log 2>&1 此处 2与output.log 中间为何没有 && 或  & ？？直觉上会觉得应该用一个“逻辑连接符”（如 & 或 &&）把它们连起来
		-  Shell 的设计中，不需要连接符号
		- & 或 && 是用来连接两个独立的完整命令的。比如 cmd1 && cmd2
		- > output.log 和 2>&1 并不是命令，它们被统称为**“重定向操作符”**（Redirection Operators），Shell 的语法规则是：多个重定向设置直接并列书写
		- Shell 规定，你可以在一个命令后面挂载任意多个重定向，它们只需要空格分开即可： 就像是给命令 ./geo2json 配置的“参数”或“修饰配件”。你可以理解为这些重定向符号是直接挂载在主命令后面的
		- 执行逻辑：它发生在“程序运行之前
		
	- 注意: 在shell中重定向标准输入、输出时候打头的必须是个动作:  ./geo2json < gpsdata.csv > output.json ,错误写法:   gpsdata.csv > ./geo2json > output.json
	- unix中:  过滤器程序特征
		- 从标准输入（stdin）读取数据：它不关心数据是从文件读的、从其他程序传来的，还是人手敲的
		- 对数据进行转换处理：比如把 CSV 格式转成 JSON 格式
		- 向标准输出（stdout）写入数据：它不关心输出是显示在屏幕上，还是保存到了文件
	- `<`: 重定向标准输入
	- `>`: 重定向标准输出 
	- ./geo2json < gpsdata.csv > output.json: 从gpsdata.csv读取内容，处理后输出到 output.json 
	- 在 C/Unix 哲学中，有一个重要的原则：stdout 应该只带纯粹的数据，而 stderr 用来带“除了数据以外的一切”
		- 假设你的 geo2json 程序正在工作
		- stdout (1)：应该只输出最终生成的 JSON 字符串。这样别人才能用 > 把它保存到文件，或者用 | 传给下一个程序
		- stderr (2)：应该输出类似 正在加载第 10 行...、完成 50%、发现一个不合规的坐标，已跳过 等信息
		- stderr (2)：应该输出类似 正在加载第 10 行...、完成 50%、发现一个不合规的坐标，已跳过 等信息（很多写得好的外部程序，会故意把所有的“人机交互信息”都发送到 stderr）
		- 在资深开发者眼中：stdout：是机器读的（给下个程序用的） ，stderr：是人读的（给开发者看的日志）
	- 重定向时候一般会使用fprintf, printf底层也是fprintf(stdout,...)
	- 文件描述符数字（如 2）与重定向符号（> 或 >>）之间绝对不能有空格: 正确写法：2>err.log 或 2> err.log
	- tips: 在java中Process#getInputStream 获取的却是外部程序的stdout (以java自己为中心的视角)
	
15. pipeline(管道)
	- pipe(|): 连接一个进程的输出与另一个进程的输入(而重定向只能用于连接同一个程序的stdin， stdout, stderr )，操作系统会处理管道的细节
	- ./bermuda <asset/spooky.csv | ./geo2json >asset/output.json  等效写法 (./bermuda | ./geo2json) <assert/spooky.csv >output.json
	- `<` 会把文件内容发送到流水线中第一个进程的标准输入， `>` 会捕获流水线中最后一个进程的标准输出
	- 除了每个进程启动时OS分配的3个标准stream, 可以通过fopen创建新数据流(每条数据流用一个指向文件的指针来表示)
	
16. 数据流
	- fopen: 打开一个stream ，返回FILE类型指针,一定要fclose 
	- C语言层面没有限制fopen可以打开的流的数量，而OS有限制(ulimit -n)
	
17. main 参数/选项:
	- main(int argc, char *argv[]): main() 函数能以字符串数组的形式读取命令行参数(字符指针数组)
	- main(int argc, char *argv[]): 一个是参数的计数，另一个是指针（指向参数字符串）数组
	- argv: Argument Vector, 一个存储字符串指针的数组。每个指针都指向你从命令行输入的一个单词。
	- argc 是 Argument Count 的缩写，表示参数的个数。它总是至少为 1（因为程序名本身占第一个位置）
	- 在 C 语言中，复杂的定义遵循“右向左”原则
	- 从“右向左”读法char *argv[]: argv[]: argv 是一个数组, *argv[]: 这个数组里存放的东西是“指针”, char *argv[]: 这些指针指向的类型是 char
	- argv[0]: 第一个参数是要运行的程序的名字, 即 第一个命令行参数其实是argv[1]
	- getopt(<unistd.h>)： 命令行选项函数, 每次调用则返回下一个参数,支持选项合并( -d now -t 合并为 -td now )
	- getopt() 可以极大地简化你的解析工作。它会自动帮你区分哪个是选项（Option），哪个是参数（Argument），并处理诸如 -abc（合并选项）的情况
	- optarg: 如果选项后面跟着一个参数（如 -f file.txt），解析后 optarg 就会指向 "file.txt"。
	- optind: 下一个待处理元素的索引
	- opterr: 设为 0 可以关闭 getopt 自动向屏幕打印错误信息。
	- optopt: 当出现未知选项或缺少参数时，保存该选项字符
	- 停止标志 --：如果用户命令行里写了 --，getopt 会立即停止解析选项，把后面所有的内容都当作普通参数
	- 参数与选项: 选项以`-`开始 ，对于负数参数为避免与选项混淆，一般使用 `--`隔开， e.g.  set_temper-ature -c -- -4
	
18. 类型
	- 为了适应硬件，C语言在不同的操作系统与处理器上使用不同的数据类型大小（C语言没有指定数据类型的具体大小）
	- 计算机的单次能处理的bit数基本决定了基本数据类型的长度(32位机器则int是32bit)
	- limits.h 、float.h 等中定义了最大、最小范围
	- c中若一个函数在使用时没有提前声明，编译器一般会默认其类型为int(即所有函数必须在main之前有声明或声明加定义)
	- 声明与定义分离（在某些情况下如递归，总有一个会出现在另一个前面，如果声明与定义总是一起出现，无法解决该问题）
	- 函数声明: 声明只是一个函数签名：一条包含函数名、形参类型与返回类型的记录(一旦声明了函数，编译器就不需要假设，完全可以先调用函数，再定义函数)
	- 头文件: 甚至可以把这些声明拿到代码外，放到一个头文件中
	- 引入头文件: `<>` 与 `""`, 尖括号，就会到标准库代码所在目录查找头文件,引号表示以相对路径查找头文件
	- 预处理: 查找 - 拷贝-替换
	- 类Unix操作系统中，标准库的头文件通常保存在 /usr/local/include 、 /usr/include 这些地方

19. 编译 
	- 预处理：修改代码、 
	- 编译：转换成汇编代码、
	- 汇编：生成目标代码(将这些符号代码汇编成机器代码或目标代码,即CPU内部电路执行的二进制代码,编译器会为每个源文件生成一个目标代码,即以单个源文件为编译单元)
	- 链接：放在一起
	- 共享变量： 为了防止两个源文件中的同名变量相互干扰，变量的作用域仅限于某个文件内。如果你想共享变量，就应该在头文件中声明，并在变量名前加上extern关键字
	- gcc -c *.c: 只编译到目标文件，不做链接（每一个 .c 文件(编译单元)在编译成目标文件（.o 或 .obj）时，内部都会包含一个专门的符号表,链接器在工作时候需要查找该表）
	- 目标文件的结构:  Linux 或 macOS 上，你可以使用 nm 或 objdump 命令来查看一个 .o 文件的符号表
		- 符号表是目标文件的“护照”和“合同”，没有它，独立的编译单元就无法联合起来组成一个庞大的程序
		- .text: 机器指令
		- .data: 已初始化的全局变量
		- .bss: 未初始化的全局变量
		- .symtab, 
		- .strtab: 字符串表（存储符号具体的名称，如 "main", "foo"）
		- .rel.text(重定位信息（告诉链接器哪些地址需要被修正）) 
	- gcc *.o -o launch: 链接所有目标文件,生成可执行文件
	- 链接器（ld）的工作其实就是**“合并与对账”**
		- 它把所有输入的 .o 文件里的 .text 段拼在一起，.data 段也拼在一起
		- 它收集所有文件的 .symtab（符号表）
		- 对账：它拿着文件 A 的“需求项”，去查文件 B、C、D 的“供应项”
		- 一旦匹配成功，它就会更新最终生成的代码，把临时的“占位地址”替换为真实的“合并后地址”
		- 链接后：最终的可执行文件中依然有一张巨大的合并后的符号表
		- Strip 操作：为了减小可执行文件体积，发布正式版时通常会执行 strip 命令。它会删掉所有不影响运行的符号（主要是调试符号和局部符号），但对于动态链接所需的符号，仍必须保留
20. make
	- make 会检查源文件和目标文件的时间戳，如果目标文件过期， make 就会重新编译它
	- make 需要知道文件之间的依赖关系(生成目标需要用哪些文件)、生成方法(生成该文件时要用哪些指令),这构成了一条规则
	- makefile: 所有目标、依赖项和生成方法的细节信息需要保存在一个叫makefile或Makefile的文件中
	- autoconf可以用来生成makefile

21. structured data type - struct 
	- struct fish{ ...}
	- 结构字段访问: dot符号
	- 结构嵌套
	- 用typedef为结构命名： struct s_fish {...}fish, 即struct有两个名字，一个是s_fish 结构名 ， 另一个是类型名字 fish， 可以只写类型名而省略结构名
	- 对于一个已经定义好的具体 struct 类型，其大小在编译完成后就是固定（涉及内存对齐问题，如留白导致从sizeof看到的大小与肉眼观测结果不一致）
	- 结构体的大小在特定编译环境下是固定的，但他等于“成员大小之和 + 编译器为了效率塞进去的填充字节”
	- 计算机总是希望数据能对齐字边界（word boundary），即跨越单次读取的宽度后导致需要多次读取数据(需要多条指令完成本来只需要一条指令的工作)
	- 代码里觉得内存是一个一个字节连续排列的，对 CPU 硬件来说，它每次从内存拿数据都是一箱一箱拿的（这一箱的大小就是“字长”）
	- 在 32 位机器上，每箱是 4 字节， 内存读取只能从 0, 4, 8, 12 ... 这种对齐的地址开始
	- 自然对齐（Natural Alignment): 起始地址必须是自身长度的倍数（每个变量都希望自己的起始地址能被自己的长度整除)
	- 只要一个变量（比如 4 字节的 int）存放在能被其长度 4 整除的地址上，数学上就能完美保证它永远不会横跨任何更大的动力边界
	- char (1字节)：可以在任何地址开始（0, 1, 2, 3...）, short (2字节)：只能在偶数地址开始（0, 2, 4...），int (4字节)：只能在能被 4 整除的地址开始（0, 4, 8...）
	- 规则是：成员之间的 Padding（确实看相邻）; 但整个结构体的大小，必须是其“最顶尖成员（对齐要求最高的那位）”的整数倍
	- 当为结构赋值时，计算机会复制结构的值
	- 结构指针：更新结构。如果想让函数更新结构变量，就不能把结构作为参数传递，因为这样做仅仅是将数据的副本复制给了函数
