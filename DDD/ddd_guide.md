# 领域驱动设计 (DDD) 核心组件完全指南

领域驱动设计 (DDD) 不仅仅是关于如何组织文件夹，它是一套应对**复杂业务逻辑**的架构思想。其核心目标是让代码的表达与真实业务保持高度一致。

---

## 1. 战术组件基础

### 1.1 实体 (Entity)
*   **定义**：具有唯一标识（ID）的对象，其生命周期内属性可能改变，但身份不变。
*   **解决的问题**：对象跟踪。例如“张三”改名叫“张小三”，但他依然是数据库里同一个用户。
*   **最佳实践**：不要只有 Getter/Setter（贫血模型），应将业务动作封装在方法内。
*   **例子**：`Order` 订单。订单号固定，即使订单状态从“待支付”变为“已发货”，它依然是那个订单。

### 1.2 值对象 (Value Object)
*   **定义**：没有 ID，仅通过属性值来定义的量。
*   **解决的问题**：过度使用基础类型（Primitive Obsession）。例如用 `decimal` 存钱，无法表达币种。
*   **最佳实践**：**不可变性**。如果值变了，直接替换整个对象。
*   **例子**：`Address` 地址、`Money` 金钱（金额+币种）。如果地址变了，我们是赋予一个“新地址”，而不是修改旧地址的某个街道字段。

### 1.3 聚合与聚合根 (Aggregate & Aggregate Root)
*   **定义**：一组具有内聚性的实体和值对象的集合。聚合根是外部访问该集合的**唯一入口**。
*   **解决的问题**：保护业务规则的一致性。防止外部直接修改子对象从而绕过业务检查。
*   **最佳实践**：通过 ID 引用其他聚合，不要直接引用对象引用。保持聚合尽可能小。
*   **例子**：`Order` 是聚合根，`OrderItem`（订单项）是其内部实体。不能直接操作 `OrderItem` 的价格，必须通过 `Order.UpdateItemPrice()` 来统一计算折扣和总价。

---

## 2. 逻辑调度组件

### 2.1 领域服务 (Domain Service)
*   **定义**：当一个操作**不属于任何特定的实体**（涉及多个对象或外部配置）时引入的无状态服务。
*   **解决的问题**：跨实体的业务协作逻辑“无处安放”的问题。
*   **最佳实践**：不要在领域服务里写本该属于实体的逻辑。
*   **例子**：`TransferService` 转账。它协调 `AccountA` 扣款和 `AccountB` 加款。这个动作不属于 A 也不属于 B。

### 2.2 应用服务 (Application Service)
*   **定义**：领域层的外部包装。负责协调领域层与外围（UI、数据库）的工作。
*   **解决的问题**：处理权限审查、事务启动、日志记录、格式转换。
*   **最佳实践**：**很薄**。它不应该包含任何业务逻辑，只负责“指派任务”给领域对象。
*   **例子**：`OrderAppService.PlaceOrder()`。它负责开启事务、从数据库捞出用户、调用 `order.Confirm()`、最后保存。

---

## 3. 技术解耦组件

### 3.1 仓储 (Repository)
*   **定义**：提供一种像操作内存集合一样操作数据库的某种抽象（通常是接口）。
*   **解决的问题**：业务逻辑与持久化技术（SQL, EF Core, Redis）的深度耦合。
*   **最佳实践**：接口定义在 **Domain 层**，具体实现在 **Infrastructure 层**。
*   **例子**：`IOrderRepository.Save(Order)`。领域层只管调用 Save，不管最后是存进了 MySQL 还是发给了一个消息队列。

### 3.2 领域事件 (Domain Event)
*   **定义**：业务中发生的具有意义的事件（通常是过去时）。
*   **解决的问题**：模块间的强耦合。实现“最终一致性”。
*   **最佳实践**：使用发布/订阅模式。
*   **例子**：`OrderPaidEvent`（订单已支付）。当订单支付后，发送邮件、增加积分、打印发货单。如果不使用事件，`Order` 类就得引用 `EmailService` 和 `PointService`。

### 3.3 数据传输对象 (DTO)
*   **定义**：用于在进程间传输数据的对象。
*   **解决的问题**：领域模型泄露。防止数据库结构或敏感字段被暴露给前端。
*   **最佳实践**：DTO 应该是扁平的，不带逻辑。
*   **例子**：`UserDetailDto`。它可能只包含用户名和邮箱，不包含数据库 ID 或加密后的密码。

---

## 4. 架构进阶工具：CQRS (读写分离)
*   **定义**：将“改变状态的操作（Command）”与“查询状态的操作（Query）”分开处理。
*   **解决的问题**：
    1.  **性能冲突**：统计类查询需要复杂的 SQL，而领域模型为了业务安全需要复杂的对象结构。
    2.  **职责混合**：防止为了做一个统计报表而在实体类里加了一堆冗余字段。
*   **最佳实践**：查询直接查数据库（Dapper/SQL），不经过 Repository，更不加载领域模型。
*   **例子**：
    *   **写操作**：`Order.Cancel()` -> 走复杂的状态校验流程。
    *   **查询/统计**：`SELECT SUM(Total) FROM Orders` -> 直接执行高效 SQL，返回 DTO。

---

---

## 6. 附录：Java & C# 生态中的 DDD 实践方案

在不同的技术栈中，DDD 的落地有许多成熟的脚手架和库支持，以下是主流选择：

### 6.1 .NET / C# 生态
.NET 的强类型特性非常适合 DDD 的严谨表达。

*   **框架推荐：ABP Framework** 🏆
    *   **地位**：.NET 领域的“神级”框架。
    *   **特点**：它不仅是一个文件夹模板，它内置了符合 DDD 的基础类（`AggregateRoot`, `DomainService`）。它强制执行层级依赖关系，并自动处理分布式事件和仓储接口。
    *   **快速开始**：使用 `abp new YourProject` 即可生成一个标准的 4 层 DDD 结构。
*   **脚手架推荐：Clean Architecture Template**
    *   **地位**：轻量级模板。
    *   **特点**：遵循 Steve Smith (Ardalis) 的规范，通过项目的 `dotnet new` 命令直接安装。适合不想被大型框架绑架，但希望获得标准 DDD/干净架构目录结构的团队。
*   **实用库：MediatR**
    *   **用途**：实现进程内的**领域事件**和 **CQRS**。它允许你在应用层发布一个 `Command`，然后由对应的 `Handler` 处理。

### 6.2 Java 生态
Java 社区对 DDD 的讨论历史悠久，方案多而全。

*   **框架推荐：Axon Framework**
    *   **地位**：专为 **Event Sourcing (事件溯源)** 和 **CQRS** 设计。
    *   **特点**：如果你想做极致的 DDD（每个状态变更都是一个不可变的事件），Axon 是行业标杆。虽然上手难，但解决分布式系统中的强一致性非常有优势。
*   **脚手架推荐：COLA (Clean Object-oriented & Layered Architecture)**
    *   **地位**：阿里巴巴内部流行的架构规范。
    *   **特点**：比起 Axon，它更接地气。它规定了详细的包命名规范（如 `domain.model`, `domain.gateway`），非常适合国内的大型互联网工程落地。
*   **实用库：Project Lombok**
    *   **用途**：虽然不是 DDD 专门库，但它能极大地减少“充血模型”中的样板代码。
*   **实用库：ArchUnit**
    *   **用途**：**守护架构边界**。你可以写一段测试代码，规定“Domain 层绝对不允许调用 Infrastructure 层”，如果有人写错了，CI/CD 环节会直接报错。

### 6.3 选型建议

| 需求                                | .NET 方案                  | Java 方案                   |
| :---------------------------------- | :------------------------- | :-------------------------- |
| **我想一步到位，快速生产**          | ABP Framework              | COLA (或 SpringBoot 纯手工) |
| **我需要处理复杂的分布式/审计账本** | EventStoreDB               | Axon Framework              |
| **我想要轻量级、自定义程度高**      | Ardalis Template + MediatR | Spring Boot + ArchUnit      |

---

## 5. DDD 核心设计原则 (总结)

| 原则                               | 核心目的                         | 解决的问题                                                               |
| :--------------------------------- | :------------------------------- | :----------------------------------------------------------------------- |
| **通用语言 (Ubiquitous Language)** | 业务专家和程序员说同一种话       | 消除通过文档和需求翻译带来的误解。                                       |
| **依赖倒置 (DIP)**                 | Domain 层不依赖外部库（DB, API） | 确保业务逻辑的纯粹性，提高可测试性。                                     |
| **充血模型**                       | 将逻辑封在对象内部               | 解决只有数据没有灵魂的“贫血模型”导致的逻辑四处漂散。                     |
| **限界上下文 (Bounded Context)**   | 给业务定边界                     | 防止一个巨大的 `User` 对象在“营销、库存、财务”各个模块里被搞得臃肿不堪。 |

**一句话建议：** 开始 DDD 的最好方法是保护好你的 `Domain` 项目，不给它添加任何数据库驱动的引用，并强迫自己给方法起名为业务动词（如 `Confirm()`）而不是技术动词（如 `UpdateStatus(2)`）。
