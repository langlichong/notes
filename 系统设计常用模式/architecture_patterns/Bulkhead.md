# Bulkhead (舱壁模式)

这种模式借鉴了造船业的物理分舱技术，将系统资源（线程池、CPU、内存）划分为相互隔离的池子。当某个池子被耗尽或发生故障时，其他池子能保持正常运转。

## 1. 痛点：一个 Bug 搞定所有接口

假设你的 Spring Boot 应用有 200 个处理线程：

```text
[HTTP 线程池 - 200个]
    ├── 用户注册接口 (轻量)
    ├── 用户登录接口 (轻量)
    └── 导出超大 Excel 接口 (沉重，占 CPU 且慢)
```

**事故场景**：
某个由于运营失误，在半小时内发起了 300 次“导出超大 Excel”。
1.  这 200 个线程会迅速被这 200 个导表任务占满。
2.  此时，正常的用户想“注册”或“登录”，由于拿不到线程，只能在那转圈直到超时。
3.  **结果**：一个“导出功能”的异常，导致“登录”和“注册”这两个核心功能也停摆了。

---

## 2. 解决方案：物理隔离资源

既然不能让它们共享一个池子，那就把池子劈开。常用的实现方式有两种：

### 方式 A: 线程池隔离 (Thread Pool Isolation) —— 最彻底
为不同的业务逻辑分配独立的线程池。
*   `User-Pool` (50 条线程)：专门给注册/登录。
*   `Export-Pool` (10 条线程)：专门给导表。
*   **结果**：即便导表炸了，用户业务那 50 条线程依然活得好好的。

### 方式 B: 信号量隔离 (Semaphore Isolation) —— 最省资源
不用开新线程池（还在主线程跑），但给特定逻辑加个“闸门”。
*   逻辑：进入 `ExportLogic` 前，必须先抢到信号量（比如只有 5 个）。
*   **结果**：并发最多只有 5 个导表在跑，剩下的直接被拒，保证了主池子永远不会过载。

---

## 3. 实现策略

在 **Resilience4j** 或 **Spring Cloud** 环境中，建议做法：

1.  **按重要性分舱**：核心路径（收钱、登录）必须拥有独立且优先的舱室。
2.  **按稳定性分舱**：经常出问题的、或者对接不稳定第三方接口的代码，必须下沉到受限的舱壁中。
3.  **物理节点分舱 (K8s实现)**：如果某个业务实在太重，直接给它建立一个独立的 Pod 集群，让原本的 Pod 完全不跑这块代码。

---

## 4. 关键：代价权衡

*   **管理的复杂性**：你需要监控 N 个线程池，而不是一个。
*   **资源利用率**：如果 `User-Pool` 很闲，`Export-Pool` 却在排队，资源不能互相借用。这是一种用 **“效率”** 换取 **“确定性”** 的做法。

---

## 5. 与熔断器的区别

*   **熔断器 (Circuit Breaker)**：关注 **“下游挂了怎么办”**。它是事后止损，断开连接。
*   **舱壁模式 (Bulkhead)**：关注 **“我内部资源怎么分”**。它是事前防御，资源隔离。
*   **黄金搭档**：在一个稳定的系统中，通常在同一个接口上**同时应用**舱壁（限制并发数）和熔断（检测下游质量）。

## 6. 总结
舱壁模式是将系统从“一个公共大厅”变成“一个个独立的包间”。
*   **优势**：极大地提高了系统的鲁棒性，确保了“局部崩溃”永远不会演变成“全盘皆输”。
*   **信条**：宁可一部分人进不来，也不让所有人跟着死。
