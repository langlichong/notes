# Retry with Exponential Backoff (指数退避重试)

在分布式系统中，瞬时的网络抖动（Glitch）是必然触发的。重试是解决这一问题的最简单手段，但“指数退避”则是解决重试过程中不至于产生“次生灾害”的科学方案。

## 1. 痛点：恐怖的“重试风暴”

如果你的代码是简单的 `while(fail) { retry(); }`:

**灾难场景**：
1.  **服务 B 短暂重启**：耗时 5 秒。
2.  **上游 A 疯狂重试**：1000 台上游服务器发现失败，立即每毫秒发起一次重试。
3.  **下游被淹没**：服务 B 刚想起步，瞬间被这几百万次的重试请求压垮，CPU 直接 100%。
4.  **死循环**：B 永远起不来，A 永远在重试。这就是著名的 **“惊群效应”**。

---

## 2. 解决方案：有节奏的后撤

指数退避要求每次重试的时间间隔成倍增加。

### 公式：`Interval = base * 2^n`
*   第 1 次失败：等待 100ms。
*   第 2 次失败：等待 200ms。
*   第 3 次失败：等待 400ms。
*   ...
*   第 10 次失败：等待约 100 秒。

**核心逻辑**：失败次数越多，说明系统问题越严重，我们应该给系统留出越来越长的恢复空间。

---

## 3. 灵魂补丁：Jitter (随机抖动)

如果只有指数退避，还不够。1000 个客户端同时失败 -> 同时等待 100ms -> 同时在第 100ms 重试。
**波峰依然存在**。

**Jitter 做法**：
在指数基础上加一个随机偏移：`Interval = (base * 2^n) +/- random_offset`。
*   结果：这 1000 个请求会错开分布在 80ms 到 120ms 之间。流量被抹平了，服务器感受不到波峰。

---

## 4. 实现指南

### 1. 适用范围
*   必须是 **幂等** 的操作（查询、带有幂等键的更新）。
*   必须是 **瞬时** 的错误（503 Service Unavailable, 408 Timeout）。如果返回 403 Forbidden 或 400 Bad Request，重试一万次也没用，直接报错。

### 2. Spring 支持
```java
@Retryable(
    value = { RemoteServiceException.class }, 
    maxAttempts = 3, 
    backoff = @Backoff(delay = 1000, multiplier = 2) // 开启指数退避
)
public void callService() { ... }
```

---

## 5. 注意事项与局限

*   **线程占用**：在同步代码里，Thread.sleep() 这种重试会占坑。在高并发下应考虑异步重试。
*   **最大限制**：不能无限退避，必须设一个 Top Limit（比如最多重试 5 次或等待 10 秒即放弃），否则会造成主链路严重积压。

## 6. 总结
指数退避是架构师的 **“礼貌”**。
*   **信条**：当由于我发现你已经撑不住时，我会离得越来越远，直到你缓过神来。
*   **价值**：它是系统自愈能力的重要一环。
