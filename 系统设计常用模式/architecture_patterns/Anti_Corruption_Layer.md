# Anti-Corruption Layer (防腐层模式)

作为领域驱动设计 (DDD) 里的经典战术模式，它在我们的优雅系统与一个外部“烂系统”之间建立一层翻译和转换介质。它确保了外部恶劣的设计无法“传染”到我们的核心逻辑。

## 1. 痛点：被外部系统的设计所绑架

当你不得不对接一个 15 年前的银行接口或内部极其简陋的遗留系统时：

```java
// 外部系统的惨样
public class OldSystemResp {
    public String F_001; // 竟然用这种名字代表余额
    public String flag_X; // 只有 0 和 1 两种字符，没有注释
}
```

**连锁反应**：
1.  **名词污染**：你在自己的业务逻辑里写 `if (old.F_001 > 0)`。半年后，没人知道 `F_001` 是什么意思。
2.  **逻辑渗透**：外部系统由于设计缺陷。返回 200 不代表成功。还需要判断 `flag_X` 为 'S'。于是你的业务逻辑写满了这些恶臭的 IF 判断。
3.  **改不动**：如果有一天外部系统升级了字段名。你全网搜索替换，结果漏掉一处。

---

## 2. 解决方案：戴上手套干脏活

我们在入口处强行阻断污染。构建一个 **Adapter (适配器)**：

### 核心转换逻辑
1.  **翻译官**：把 `F_001` 转换为 `Balance`。
2.  **清洗员**：把逻辑判断 `(flag_X == 'S' && code == 200)` 在防腐层内消化掉。对外只返回一个干净的布尔值 `isSuccess`。
3.  **协议转换**：外部是怪异的 XML 或二进制。防腐层将其转为我们喜欢的领域对象（Entity / DTO）。

---

## 3. 实现结构

```bash
[My Service Core] <--> [Anti-Corruption Layer (Translator)] <--> [Ugly Legacy System]
```

*   **隔离端**：防腐层通常属于调用方（My Service）的一部分。
*   **单向依赖**：My Service 的逻辑只依赖防腐层的定义的标准接口，严禁直接引用外部系统的外部包/实体。

---

## 4. 关键价值

*   **自主权**：我们可以根据当前最好的架构理念设计核心模型。不被外部系统的平庸所限制。
*   **低成本更换**：如果明天要从 A 银行切到 B 银行。我只需要重写一遍防腐层代码，核心业务逻辑 **一行都不准动**。

---

## 5. 注意事项与弊端

*   **开发量翻倍**：你需要多写一套 DTO 和 Mapping 代码。对于那种极其简单的临时调用，这显得很冗余。
*   **掩盖问题**：如果过度使用防腐层。可能会掩盖底层系统已经坏透了、需要彻底重写的事实。

## 6. 总结
防腐层是系统的 **“免疫系统”**。
*   **核心逻辑**：你可以很脏，但我追求纯净。
*   **心法**：界限明确，绝不妥协。在混乱的集成环境中，它是保持代码优雅的最后港湾。
