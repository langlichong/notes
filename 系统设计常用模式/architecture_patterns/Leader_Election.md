# Leader Election (领导者选举模式)

在分布式多实例环境中，有些特定的任务（如发定时任务、刷新缓存、作为主控节点）必须确保在同一时间 **“全球唯一执行”**。这种模式通过一系列算法在多个候选者中选出一名 Leader，确保权力的统一和有序分配。

## 1. 痛点：脑裂与多头指挥

当你部署了 3 个 `Job-Worker` 实例：

**事故场景**：
1.  **全量执行**：凌晨 0 点。3 个实例同时苏醒。
2.  **灾难后果**：它们各自给同一个用户发了 3 封工资邮件。或者更严重的。3 个进程同时去结算同一个订单的余额。
3.  **并发冲突**：由于它们互相不知道对方的存在，导致数据库发生了严重的死锁或数据覆盖。

**根本原因**：虽然服务是分布式的，但业务逻辑是**排他性**的。

---

## 2. 解决方案：主从权力机制

通过共识机制产生唯一的 Leader：

### 核心流程
1.  **选举 (Election)**：所有的实例在启动时，去一个“绝对公正”的第三方（ZooKeeper/Redis/Etcd）那里抢一把锁。
2.  **任职 (Leadership)**：抢到那个特定 ID 的实例成为 Leader。其他所有人转为 **Follower (Standby)**。
3.  **续约 (Heartbeat/Lease)**：Leader 必须定期证明自己还活着。
4.  **禅让/抢班夺权**：如果 Leader 死机了（没续约）。锁自动释放。剩下的 Follower 感知到后，开始新一轮的抢夺。

---

## 3. 实现手段

*   **ZooKeeper Ephemeral Node**：最成熟保证。创建临时节点。谁名字短谁当选。
*   **Redis SETNX + Expiration**：性价比最高。抢分布式锁。
*   **数据库唯一键**：最原始的做法。插入一条特定记录。

---

## 4. 关键挑战：脑裂 (Split-Brain)

**极端情况**：Leader 1 其实没死。它只是发生了 15 秒的 JVM 全局停顿 (Full GC)。
1.  第三方检测系统由于等不到续约。判定它死了。选出了 Leader 2。
2.  此时 Leader 1 醒来了。它也觉得自己还是 Leader。
3.  **全案崩盘**：系统中出现了两个 Leader 同时干活。

### 怎么防？
*   **Fencing Token（击剑标志）**：每个 Leader 任职时都有个单调递增的版本号。下游数据库每次操作前检查：如果这个版本号比我之前见过的旧。说明你是过期 Leader。**直接拒绝你的一切写操作。**

---

## 5. 适用场景

*   **定时任务调度器**。
*   **分布式系统元数据管理 (Master Node)**。
*   **资源锁定管理器**。

## 6. 总结
领导者选举是分布式系统稳定性的 **“最高决策中心”**。
*   **信条**：我可以有很多将军。但我只能有一个统帅。
*   **代价**：复杂的算法实现。如果选主逻辑本身出了 Bug，整个系统会陷入无间断的“篡位与被废黜”的死循环中。
