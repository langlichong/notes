# Circuit Breaker (熔断器模式)

类似于家用电路中的“保险丝”，这种模式用于在检测到下游服务故障时，为了防止由于局部故障蔓延导致整个应用崩溃（雪崩效应），而主动断开连接的一种自我保护机制。

## 1. 痛点：失控的级联崩溃 (Cascading Failures)

在微服务环境中，请求链路可能是：`A -> B -> C -> D`。

```bash
[服务 A] -> 发起请求 -> [服务 B (由于 DB 慢查询响应极慢)]
```

**连锁反应**：
1.  **服务 A 等待**：服务 A 的请求线程被挂起，等待 B 返回。
2.  **线程池爆满**：由于 A 依然在接收外界请求，越来越多的线程被卡在等待 B 的过程上。
3.  **服务 A 瘫痪**：服务 A 没有剩余线程处理其他不依赖 B 的请求。
4.  **雪崩**：依赖 A 的上游系统 C 也会跟着挂掉，最后全线崩溃。

**本质原因**：一个缓慢的依赖项比一个直接报错的依赖项更致命，因为它会“吸干”你的系统资源。

---

## 2. 解决方案：状态机管理

熔断器是一个包裹在远程调用外层的 **状态机**，它实时监控成功的比例：

### 状态 A: Closed (关闭 - 正常)
所有请求放行。熔断器默默记录成功率。如果失败率低于阈值（如 50%），它保持闭合。

### 状态 B: Open (打开 - 跳闸)
一旦失败率达到阈值，熔断器跳闸。
*   **动作**：接下来的所有请求**立即报错 (Fail Fast)**，不尝试连接下游。
*   **目的**：给下游服务 B 喘息的时间，同时也释放了服务 A 的本地线程。

### 状态 C: Half-Open (半开 - 尝试)
进入 Open 状态一段时间后（如 30 秒），熔断器进入半开状态。
*   **动作**：只放行少量请求去试探下游。
    *   **试探成功**：下游好了！重回 Closed 状态。
    *   **试探失败**：下游还没好。重回 Open 状态，再等一会儿。

---

## 3. 实现策略

### 核心：降级逻辑 (Fallback)
熔断后不应只是抛异常。架构师需要设计“优雅的退路”：
*   **返回默认值**：如“当前由于网络原因暂时无法展示行情”。
*   **返回缓存**：旧的汇率总比崩溃强。
*   **存入重试队列**：后台慢慢重试。

### 实现框架
*   **Sentinel (阿里开源)**：功能极其强大，支持控制面板实时调节阈值。
*   **Resilience4j**：目前 Java 社区最主流的轻量级库（替代已停止维护的 Hystrix）。

---

## 4. 关键：阈值的设计

*   **失败率百分比**：如 30 秒内 50% 的请求失败。
*   **最小请求数**：如果 30 秒内只有 1 个请求且失败，不应跳闸。必须满足最小基数（如 20 个）。
*   **慢调用阈值**：如果 90% 的请求 RT (响应时间) 超过 2 秒，也应触发熔断。

---

## 5. 常见挑战

1.  **盲目全量恢复**：如果半开状态下瞬间切回全量，可能会瞬间把刚活过来的下游再次打死。需要支持“预热”或阶梯式恢复。
2.  **监控缺失**：熔断是故障的信号。必须配置即时告警，确保开发人员知道保险丝断了。

## 6. 总结
熔断器是用 **“部分功能的暂时残缺”** 换取 **“整个系统的存活”**。
*   **口诀**：大难临头各顾各，断尾求生保核心。
