# Idempotency Key (幂等键模式)

一种在分布式环境中确保操作 **“仅执行一次”** 的抗风险模式。它解决了由于网络超时重试引发的重复扣款、重复下单等严重业务事故。

## 1. 痛点：不可靠的网络连接

在分布式系统里，请求的结果只有三种状态：**成功、失败、未知（超时）**。

```bash
用户点击 [支付] -> 请求发往后端 -> 后端处理扣款成功 -> [网络突然断了] -> 前端超时报错。
```

**问题**：此时用户看到“交易超时”，为了成功，他会再次点击 [支付]。
*   **后果**：由于后端已经扣过一次款了，再次请求会执行第二次扣款。

**结论**：在不可靠的网络下，重试是必须的。但如果没有幂等保护，重试就会变成灾难。

---

## 2. 解决方案：给每个请求发个“身份证”

在发起关键写操作前，客户端生成一个全局唯一的 **Idempotency Key (通常是 UUID)** 并放在 Header 或请求体中。

### 后端处理逻辑：
1.  **查重**：收到请求，先去存储（通常是 Redis 或 DB 唯一索引）查该 Key 存在吗？
2.  **处理中锁**：如果不存在，以原子的方式（如 `SETNX`）设置该 Key，状态为 `PROCESSING`。
3.  **生产业务**：执行实际的写操作。
4.  **记录并返回**：业务成功后，将执行结果关联到这个 Key，状态改为 `COMPLETED`。
5.  **重复请求重定向**：如果步骤 1 发现 Key 已存在，**直接返回之前存储的结果**，不再重新执行业务逻辑。

---

## 3. 实现策略

### 策略 A: 数据库唯一索引 (最强一致性)
在业务事务里，强行向一张 `idempotency_log` 表插入该 Key。
*   **优点**：利用数据库事务，保证业务成功和 Key 保存是原子性的。
*   **场景**：极高价值的交易（扣款）。

### 策略 B: Redis 状态机 (高性能)
利用过期时间自动清理过旧的 Key。
*   **逻辑**：`SET key-123 PROCESSING NX EX 3600`。
*   **场景**：高频、价值适中的场景（如点赞、评论冗余、重复发券）。

---

## 4. 关键：什么时候生成 Key？

*   **原则**：Key 必须在 **“业务意图产生时”** 生成。
*   **正确示例**：用户打开支付弹窗的一瞬间，前端生成 Key。只要这个弹窗没关，重复点“确定”，发出的都是同一个 Key。
*   **错误示例**：后端在接口入口处根据 `userId + timestamp` 算一个 Key（这没用，因为时间戳每次重试都变）。

---

## 5. 常见挑战

1.  **结果的一致性**：如果第一次请求失败了（业务报错），第二次请求进来应该允许它重新尝试业务，还是直接返回上次的报错？通常建议：**只有成功的结果才被强制幂等返回**。
2.  **有效期选择**：Key 应该保存多久？通常建议保留 24~48 小时，足以覆盖大部分的网络重试周期。

## 6. 总结
幂等键是后端服务的 **“防火墙”**。
*   **核心收益**：让前端和下游调用者可以放心地进行重试（Retry Support）。
*   **心法**：不仅要通过代码层面的原子检查，更要确保 Key 的生命周期与业务意图严格绑定。
