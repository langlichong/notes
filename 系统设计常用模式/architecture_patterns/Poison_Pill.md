# Poison Pill (毒丸模式)

一种专门针对异步处理流程的容错机制。它识别出那些由于数据格式错误、逻辑漏洞等原因导致处理端无法正确解析且会反复触发崩溃的特殊消息，并将其安全地隔离。

## 1. 痛点：一颗老鼠屎坏了一锅粥

假设你有一个订单队列，100 个消费者在处理消息。

**灾难场景**：
1.  **坏消息进入**：有一条消息，由于代码 Bug 导致反序列化时抛出 `NullPointerException`。
2.  **自动重回队列**：根据 MQ 默认策略，处理失败 -> `NACK (不确认)` -> 消息回到队列头部。
3.  **循环往复**：
    *   消费者 A 拿到，崩了。
    *   消息滚回，消费者 B 拿到，崩了。
    *   消费者 C 拿到...
4.  **全系统空转**：整个集群所有的 CPU 全在忙着处理这条“坏消息”然后崩溃重启。后面千万张真实的合法订单被挡住，无法处理。

**本质原因**：系统的重试机制过于单纯，没有意识到某些错误是 **“硬错误”** (无论重试多少次都过不去)。

---

## 2. 解决方案：死信队列 (DLQ) 与生命计数器

### 步骤 A: 记录投递次数 (Delivery Count)
在消息头（Header）中维护一个计数器。每次投递失败回滚，计数器 +1。

### 步骤 B: 设定毒性阈值 (Poison Threshold)
定义一个阈值（通常是 3 次或 5 次）。
*   如果 `Count < 阈值`：继续重试，这可能是网络抖动。
*   如果 `Count >= 阈值`：标记为“毒丸”。

### 步骤 C: 隔离到死信队列 (Dead Letter Queue)
一旦确认为毒丸，不再发回主队列。将其直接丢入专门的 `DLQ_SERVICE_X`。

---

## 3. 实现策略

### 1. 利用 MQ 原生能力 (RabbitMQ / RocketMQ)
这些成熟的消息队列原生支持 DLQ 配置。你只需要在创建 Queue 时指定 `x-dead-letter-exchange` 即可。

### 2. 业务代码捕获
在使用 Kafka 时，通常通过代码捕获特定的不可恢复异常：

```java
try {
    process(msg);
} catch (JsonParseException e) {
    // 这种错重试万次也白搭，直接手动扔进死信表
    saveToDlq(msg); 
    ack(msg); // 然后从原队列里消费掉，免得卡死
}
```

---

## 4. 关键：死信后的后续

入库（DLQ）不是终点，如果不处理，它只是一个“隐藏的定时炸弹”：

1.  **即时报警**：凡是进入 DLQ，必须触发 P1 级报警，意味着有 Bug 或黑客攻击。
2.  **人工排查**：开发人员下线该消息，修复逻辑后，再通过一个管理界面把消息重新放回主队列（重试）。

---

## 5. 常见挑战

*   **混淆了瞬时负载和毒丸**：如果下游数据库挂了，会导致所有消息都进 DLQ。这种情况应该暂时停掉消费者，而不是把消息都扔进死信。
*   **消息过期**：死信队列如果没被查看，可能也会存满。

## 6. 总结
毒丸模式是异步处理系统的 **“垃圾分类器”**。
*   **核心逻辑**：识别出那些“不可救药”的任务，给核心链路腾出空间。
*   **一句话口诀**：重试三次是不行，请进死信查清因。
