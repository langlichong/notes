# Health Check (健康检查模式)

现代自愈架构的基石。它不仅探测一个进程是否存在（是否有呼吸），更深度探测该进程是否具备对外提供服务的能力（能否走路）。

## 1. 痛点：活着，但已“灵魂出窍”

最诡异的生产故障通常不是进程挂了，而是 **“假死”**：

*   **JVM 死锁**：进程还在，线程全卡死。
*   **连接池耗尽**：进程能接收请求，但连不上数据库，业务全线报 500。
*   **OOM 后遗症**：虽然没挂，但频繁 Full GC，响应时间从 100ms 变成 10s。
*   **僵尸模式**：容器启动了，但还没加载完庞大的 Spring 配置文件，此时负载均衡器就把流量导进来了，结果全报错。

**结论**：如果运维系统只看 `PID`，就无法发现这些问题，导致用户请求白白掉进“黑洞”。

---

## 2. 解决方案：分层的探针策略

在 K8s 和现代容器云中，我们将健康检查拆分为两大类：

### 类型 A: 存活探测 (Liveness Probe) —— “确定要不要杀掉你”
*   **目的**：解决死锁、假死等无法恢复的故障。
*   **动作**：如果检测失败，系统会强制杀死并冷重启该 Pod。
*   **口诀**：不跳了（心跳停了），原地复活。

### 类型 B: 就绪探测 (Readiness Probe) —— “确定能不能分你流量”
*   **目的**：解决启动加载慢、数据库临时由于网络波动导致无法写库等。
*   **动作**：如果检测失败，系统**不会重启**你，而是把你从负载均衡列表中剔除。
*   **口诀**：没准备好，别让客人进来，等好了再接客。

---

## 3. 实现策略

### 深度探测 (Deep Check)
不要只写一个 `return "OK"` 的控制器。利用 Spring Boot Actuator 的逻辑：
*   **连外存**：向 Redis 发个 `PING`。
*   **连数据库**：发个 `SELECT 1`。
*   **查内部**：查一下内存占用和线程活跃度。

### 配置技巧 (K8s YAML 示例)
```yaml
livenessProbe:
  httpGet:
    path: /actuator/health/liveness
    port: 8080
  initialDelaySeconds: 60 # 给 Spring Boot 留够启动时间，别一启动就杀掉
  periodSeconds: 10      # 每 10 秒查一次
```

---

## 4. 注意事项：防止“全体阵亡”

这是一个真实的血泪教训：
*   **多米诺骨牌效应**：你的数据库因为太累变慢了。所有 Pod 的健康检查都去 `SELECT 1`。
*   **结果**：数据库回包慢，导致所有 Pod 的健康检查超时。K8s 判定所有服务“挂了”，**竟然同时重启了几百个 Pod**。
*   **惨状**：本来只是慢，现在是全线下线，数据库还没缓过来，几百个启动流量再次冲进来，系统彻底崩盘。

**优化方案**：
1.  **探针要轻**：不要在探测里写复杂的 SQL。
2.  **设置重试次数**：连续失败 3 次再断定已死。

## 5. 总结
健康检查是自愈系统（Self-healing）的眼睛。
*   **核心逻辑**：服务质量不代表服务存活。
*   **心法**：精细区分 Liveness 和 Readiness，给系统留出缓过神来的时间。
