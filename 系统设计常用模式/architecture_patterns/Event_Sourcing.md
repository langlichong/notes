# Event Sourcing (事件溯源)

放弃存储“当前状态”，改为存储产生状态的“每一个事件”。通过从头开始“重放（Replay）”这些事件，我们可以找回任意时间点的数据快照。

## 1. 痛点：消失的过去

在传统的增删改查（CRUD）中，数据是**破坏性更新**的：

```sql
UPDATE accounts SET balance = 100 WHERE id = 1;
```

**问题**：当我看到余额是 100 时，我不知道它是怎么变成 100 的。他是从 50 加到了 100？还是从 200 扣成了 100？

*   **审计困难**：如果出现错账，我必须去查几天前沉重的归档日志。
*   **纠错难**：如果昨天一段计奖逻辑写错了，算多发了钱。在 CRUD 数据库里，我很难准确找出受影响的人并精准回退。
*   **无法预测未来**：我想测试新的算法应用在过去一年的数据上会产生什么结果，CRUD 模型无法支持。

---

## 2. 解决方案：只增不减的事件流

在 Event Sourcing 中，唯一的事实源是 **事件日志 (Event Store)**。

*   **不再存**：`account_id: 1, balance: 100`。
*   **改为存**：
    1.  `{ type: "AccountOpened", id: 1, init: 0 }`
    2.  `{ type: "MoneyDeposited", amount: 150 }`
    3.  `{ type: "MoneyWithdrawn", amount: 50 }`

当你想知道当前余额时，程序会从事件 1 算到事件 3：`0 + 150 - 50 = 100`。

---

## 3. 实现策略

### 核心设计：Append-Only Log
数据库只支持 `INSERT` 和 `SELECT`，绝对不允许 `UPDATE`。这意味着它天然具备防篡改特性。

### 性能优化：快照 (Snapshotting)
如果一个账户有 100 万个事件，每次查询重放太慢。
*   **策略**：每隔 1000 个事件，计算一个快照（如：“第 1000 个事件时的状态是 400 元”）存起来。
*   **查询**：直接从最近的快照开始重放剩下的事件。

### 模式搭配：CQRS
Event Sourcing 几乎必须搭配 CQRS。因为事件库查明细很慢，你需要把事件同步到一个“读库”（如 MySQL/ES）里，方便前端直接查询当前状态。

---

## 4. 独特的价值

1.  **分布式追踪的终点**：你可以精准地看清业务流转的每一步。
2.  **时间旅行 (Time Travel)**：你可以轻松实现“查看这个用户在 2023-12-01 时刻的账户全貌”。
3.  **预测性测试**：你可以拿着真实的生产事件流，在测试环境下跑新代码，验证业务逻辑。

---

## 5. 注意事项与挑战

*   **版本兼容 (Versioning)**：如果 2 年前存的 `OrderEvent` 字段叫 `user_id`，而现在的代码改叫 `customer_id`。你的代码必须具备“老版本事件处理”的能力。
*   **并发控制**：多个请求同时产生事件时，需要利用版本号（Sequence Number）做乐观锁。
*   **逻辑删除**：数据不能真的删，只能插入一个 `DataDeletedEvent` 事件。

## 6. 总结
Event Sourcing 是将数据视为 **“动态的过程”** 而非 **“静态的结果”**。
*   **适用**：金融核心组件、协作工具（如 Google Docs）、需要深度审计的系统。
*   **成本**：极高的心理门槛和存储开销。
