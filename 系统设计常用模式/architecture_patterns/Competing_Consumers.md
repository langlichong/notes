# Competing Consumers (竞争消费者模式)

一种在异步处理流程中，通过让多个完全一样的消费者进程同时监听同一个消息通道，来应对大规模数据吞吐并解决 **“单点处理能力瓶颈”** 的经典横向扩展模式。

## 1. 痛点：生产力跟不上生产力

假设你有一个视频转码系统：

```bash
[上传服务] (每秒上传 100 个视频) -> [MQ 队列] -> [转码节点 A] (每秒只能转码 1 个)
```

**问题现状**：
1.  **队列积压**：5 分钟后，队列里已经堆了 10 万个任务。用户在前端反馈：`“我的视频提交完半天了。为什么状态还是‘等待中’？”`
2.  **单点局限**：转码节点 A 的 CPU 已经 100% 了，你没法通过给它加内存来提速（转码是全算力密集型）。
3.  **可靠性低**：如果转码节点 A 挂了。所有任务就完全停滞。

---

## 2. 解决方案：人多力量大 (Worker Groups)

MQ 不再只对接一个节点。而是对接一个 **消费者群组**。

### 运行逻辑
1.  **抢占式分配**：MQ 中有一条消息。10 个消费者都在那等待。
2.  **唯一性保障**：MQ 服务器通过加锁机制。确保这条消息只分给其中 **“抢得最快的一个”**。
3.  **状态确认 (ACK)**：只有消费者发送了 ACK。MQ 才认为处理成功并移出队列。否则会分给别人重试。

---

## 3. 实现策略

### 1. 技术选型
*   **RabbitMQ / ActiveMQ**：天然支持。
*   **Kafka**：通过 **Consumer Group** 实现。每个 Group 内的实例竞争不同的 **Partition**。

### 2. 动态扩缩容 (Auto-scaling)
结合 K8s HPA。
*   **Metric**：监控 `rabbitmq_queue_length`。
*   **动作**：如果积压超过 1000 条。自动把转码服务的 Pod 副本数从 1 加到 50。积压清空后降回 1。这就是弹性伸缩的精髓。

---

## 4. 关键：代价权衡

*   **完全丢失顺序性 (No Ordering)**：这是最致命的。多个消费者处理速度不同。原本先发的消息 1 可能因为消费者 A 的 CPU 慢了，导致消息 2 先完成。
    *   **应对**：如果逻辑对顺序敏感，必须使用单消费者模式（或者 Partition 绑定）。
*   **资源竞争**：如果 50 个消费者同时并发去写同一个数据库。消费者扛住了，**数据库会被瞬间压死**。

---

## 5. 适用场景

*   **完全独立、无序的任务**：发邮件、图片压缩、日志分析。
*   **任务极其耗时**：转码、复杂数学建模。

## 6. 总结
竞争消费者模式是将系统从“单兵作战”提升至 **“兵团作战”**。
*   **核心逻辑**：单兵再强也有极限，团队作战才能应对洪峰。
*   **心法**：确保任务之间是无关联的。同时要关注后端共享资源（DB/IO）的承压上限。
