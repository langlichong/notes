# Strangler Fig (绞杀榕模式)

一种用于对遗留单体系统（Monolith）进行微服务化改造的最稳健模式。它主张不推倒重写，而是通过逐步蚕食旧系统的功能、在边缘生长出新服务，最终让旧系统自然消亡。

## 1. 痛点：大爆炸式重构的必败局

当一个系统的代码积累了 10 年，变成一个谁也看不懂的“大泥球”时。

**错误尝试**：
“我们停更 3 个月，所有人脱产把这个系统用 Java/Go 重写一遍。”
1.  **无法停更**：业务在跑，竞争对手在追。你停更 3 个月意味着公司自杀。
2.  **需求漂移**：旧系统在 3 个月里又偷偷加了 100 个功能。你的新系统永远追不上。
3.  **最终烂尾**：由于复杂度超标，新系统做成了半拉子工程，钱花光了，系统还是上线不了。

**结论**：不要试图战胜已经成规模的怪兽，要试图通过物种竞争替代它。

---

## 2. 解决方案：边缘替代与路由牵引

绞杀榕模式将重构分为四个渐进步骤：

1.  **设置拦截器 (Interceptor)**：在单体和用户之间架设一个网关（Nginx, Gateway）。
2.  **新功能生长 (Transformation)**：新需求不再往单体里写。直接启动一个新的微服务（如 Java Spring Boot）。网关配置一条新路径指向它。
3.  **存量功能搬迁 (Coexistence)**：选一个独立性好的模块（如“搜索”）。在微服务里重写这个模块的代码。
4.  **牵引切流 (Elimination)**：修改网关路由。把 `/api/search` 从指向单体改为指向微服务。

---

## 3. 并行与共存期挑战

在这个漫长的绞杀过程中（可能持续 1-2 年），你会面临：

*   **数据双向同步**：老系统写一张表，新系统可能也要用同样的库。需要利用 **CDC (Canal/Debezium)** 保持两边状态同步。
*   **登录态共享**：单体可能是用的 Session。新系统是 JWT。需要通过网关或拦截器做“登录态翻译”。

---

## 4. 关键：模块选择的顺序

不要一上来就搞核心库。
1.  **先搞简单的、低风险的**：比如静态内容显示、报表导出。
2.  **再搞高频变化的**：这样能证明新系统的开发效率优势。
3.  **最后攻克“大动脉”**：账务、用户中心。这些是绞杀榕最后的树心。

---

## 5. 注意事项

*   **不要回头**：绝不允许为了省事，在老代码库里再加新逻辑。
*   **坚持绞杀**：如果绞杀了一半不干了，你就得到了一个 **“比之前更复杂的，带有两个环境垃圾的超大型烂摊子”**。

## 6. 总结
绞杀榕模式是架构上的 **“温和改革”**。
*   **信条**：通过 incremental value (增量价值) 逐步赢得信任。
*   **口诀**：网关打头阵，新苗旁边蹲，蚕食旧领土，老树了无痕。
