# Cache-Aside (旁路缓存模式)

业界应用最广的、由 **“应用程序负责维护一致性”** 的缓存模式。它通过特定的读写协议，在极致响应速度与数据新鲜度之间寻找平衡点。

## 1. 痛点：失衡的读写性能

在现代 Web 应用中，**读写比通常在 10:1 甚至 100:1 以上**。

*   **数据库压力**：如果每次查询（如商品配置、用户信息）都直接去 MySQL 做全文检索或复杂计算，DB 的 CPU 会瞬间爆表。
*   **响应延迟**：DB 磁盘 IO 永远是微服务链路中最慢的一环。

**直觉方案**：把数据存在 Redis 内存里。
**衍生问题**：如果数据库改了，Redis 里的旧数据怎么办？如果不处理，用户看到的就是错误的信息。

---

## 2. 运行协议：标准的三步走

### 场景 A：数据查询 (读)
1.  写代码：先从 Cache 读数据。
2.  **命中**：直接返回。
3.  **未命中**：从 DB 加载数据 -> 将数据同步写回 Cache -> 返回。

### 场景 B：数据更新 (写)
1.  **核心顺序**：先写数据库。
2.  **关键动作**：**直接删除 (Invalidate) 缓存**。

---

## 3. 为什么是“删除”而不是“更新”缓存？

这是面试频率最高的一点。如果选择“更新”缓存，在高并发下会导致 **数据污染**：

*   **案例**：有两个线程 A 和 B 同时发起更新。
    1.  线程 A 写 DB (值=10)。
    2.  线程 B 写 DB (值=20)。
    3.  [由于网络抖动] 线程 B 先把 Cache 改成了 20。
    4.  线程 A 后把 Cache 改成了 10。
*   **后果**：DB 是 20，Cache 是 10。**如果不等缓存过期，数据将永远是错的！**
*   **结论**：使用“删除”模式，后续的读请求由于 Miss 会重新从 DB 拉取最新值，天然避免了顺序竞争导致的一致性问题。

---

## 4. 极致一致性：延时双删 (Advanced)

即便用了“先写 DB 后删缓存”，在极端并发下仍有一线风险：
*   读请求没中 -> 刚查出 DB 旧值 -> 写请求更新了 DB 删了缓存 -> 读请求把刚查出的**旧值**又写回了缓存。

**解决方案**：
1.  执行 `先写 DB 再删缓存`。
2.  **休眠几百毫秒**（确保所有之前的读请求已处理完）。
3.  **再次执行删除缓存**。

---

## 5. 注意事项与防坑指南

1.  **缓存击穿**：热点 Key 突然失效。建议对热点数据不设物理过期时间，而是设置逻辑过期（代码判断）。
2.  **缓存穿透**：查询根本不存在的非法 Key。建议对空结果也进行简短缓存（如 5s），或使用布隆过滤器。
3.  **数据库失败**：如果 DB 写成功了，缓存删除失败怎么办？
    *   **策略**：将“删除缓存动作”发到消息队列，确保重试直到成功。

## 6. 总结
Cache-Aside 是“单点写、多点读”场景的基石。
*   **优势**：逻辑简单，不依赖复杂的分布式锁。
*   **抉择**：如果你能容忍数据库更新到缓存失效这几毫秒内的极短不一致，它是最高效的方案。
