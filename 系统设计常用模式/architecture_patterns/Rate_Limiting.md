# Rate Limiting (限流模式)

通过控制在特定时间内允许进入系统的请求数量，来保护核心系统免受由于流量超负荷（突发洪峰或恶意攻击）而导致的崩溃。它是系统性能保障的 **“减流阀”**。

## 1. 痛点：被流量巨浪淹没

没有限流的系统，应对能力是呈断崖式的。

```bash
[预期流量: 1000 QPS] -> [实际流量: 10000 QPS]
```

1.  **数据库被打爆**：海量请求冲击 DB，瞬间吃满所有连接。
2.  **集群脑裂/假死**：内存和 CPU 爆表，节点开始频繁重启或无法响应汇报心跳。
3.  **全链路崩溃**：一个入口被打崩，所有下游服务也被垃圾流量占据。

**核心问题**：系统的资源是有限的。如果不做入口控制，溢出的流量不仅会把自己打垮，还会浪费大量能量处理注定会超时的废弃请求。

---

## 2. 解决方案：流量调度算法

限流不仅要“挡住”，还要挡得“优雅”。

### 算法 A: 令牌桶 (Token Bucket) —— 允许突发
*   **原理**：系统恒定产生令牌放入桶中。请求必须拿到令牌才能走。
*   **特点**：如果桶是满的，允许瞬间通过一大波请求（突发性），比较人性化。

### 算法 B: 漏桶 (Leaky Bucket) —— 强行平滑
*   **原理**：水（请求）随便灌，但底部的孔（处理速度）是恒定的。
*   **特点**：彻底消灭突发流量，输出永远平滑稳定。

### 算法 C: 固定/滑动窗口 —— 简单粗暴
*   **原理**：每秒限制 100 个。
*   **坑**：小心“临界点”问题（第一秒的 999ms 进 100 个，第二秒的 001ms 进 100 个。瞬时 2ms 内进了 200 个，容易崩）。

---

## 3. 实现策略

### 1. 网关限流 (Ingress Limiting)
在 Nginx, Gateway, Istio 入口处限流。屏蔽恶意攻击和外部非法大流量。

### 2. 节点限流 (Node Limiting)
每个 Spring Boot Pod 保护自己。利用 Guava 的 `RateLimiter` 限制自己每秒最多处理多少。

### 3. 分布式限流 (Global Limiting)
利用 Redis 原子计数器统计全集群的总 QPS。适合做 API 套餐限制（如：每个用户每天只能调 5000 次接口）。

---

## 4. 关键：限流后的动作

当请求被拦截时，不应只是简单丢弃，需要有业务反馈：

*   **HTTP 429 Too Many Requests**：标准做法。
*   **延迟重试建议**：在 Header 里告知客户端 `Retry-After: 60`。
*   **服务降级**：比如展示静态缓存页面，而不是直接报错。

---

## 5. 注意事项

1.  **用户体验**：限流太死会导致用户流失。应分场景：秒杀要死磕限流，普通登录要适当放宽。
2.  **精细化限流**：不要只按 IP 限流（因为很多共用出口 IP）。应结合 API + UserID + ClientType 综合计算。

## 6. 总结
限流是架构师的一场 **“弃子保护”**。
*   **核心逻辑**：通过牺牲 5% 的溢出流量，保全 95% 的正常服务。
*   **心法**：限流永远不应该是单点的，必须从“端-网关-应用-数据库”进行全路径防护。
