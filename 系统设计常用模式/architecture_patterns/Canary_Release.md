# Canary Release (金丝雀/灰度发布)

金丝雀发布得名于煤矿工人带鸟入井。通过在全量发布前先部署极小部分的生产流量。在这种模式下，真实用户会被悄悄地导向新版本，通过极小样本的真实反馈来规避大规模爆发性事故。

## 1. 痛点：测试环境无法模拟真实世界

很多隐藏的 Bug 只在以下情况爆发：
*   **海量并发**：线程池由于高频率的某种调用发生锁竞争。
*   **数据多样性**：某个用户的老旧脏数据触碰了新逻辑的边界。
*   **环境差异**：生产环境的网络配置、磁盘性能与测试服务器完全不同。

如果你用蓝绿部署（全量切换），一旦 v2.0 有一个这种 Bug，那么 **100% 的用户都会受影响**（虽然可以快速切回）。

---

## 2. 解决方案：逐步扩大的灰度圈

金丝雀发布的精髓不在于“换”，而在于 **“递增”**：

### 阶段 1: 试水 (1% 流量)
*   **目标**：探测是否有明显的 Crash。
*   **手段**：只部署 1 台新实例。通过负载均衡按权重（1:99）分配。

### 阶段 2: 观察期 (10% - 20% 流量)
*   **目标**：观察性能指标（CPU, 内存, RT）。
*   **手段**：扩大灰度范围。观察错误日志是否增多。

### 阶段 3: 全线进攻 (50% -> 100%)
*   **目标**：最后全面替代旧版本。

---

## 3. 实现策略

### 1. 流量切分方式
*   **按权重**：纯粹的概率（1% 的请求发给 v2）。
*   **按标签 (Sticky)**：针对特定用户 ID、所在城市，或内部员工测试（通过 Header 识别）。这是为了保证某个用户始终在同一个版本里，不至于一会儿看到旧版一会儿看到新版。

### 2. 云原生实现 (Istio)
如果你使用 Service Mesh，一句话就能实现金丝雀：
```yaml
web-service:
  subsets:
    - name: v1
    - name: v2
  trafficPolicy:
    weight: [v1: 95%, v2: 5%] # 设置权重
```

---

## 4. 关键：自动化回滚

金丝雀发布的灵魂是 **自动化监控**。
如果 v2 的 500 错误率超过全应用均值的 5% -> **自动触发回滚**，将流量重定向回 v1。这一步不能等人去手动点，必须是监控系统驱动。

---

## 5. 常见挑战

1.  **基础设施成本**：相比蓝绿部署（2倍），它只需要增加 1 台实例作为实验。相对便宜。
2.  **数据双写挑战**：在灰度期间，v1 和 v2 都在写库。同蓝绿一样，必须保证数据库脚本的前后兼容。

## 6. 总结
金丝雀发布是微服务治理的 **“排雷兵”**。
*   **核心收益**：将故障的影响半径（Radius of blast）从“整座城市”缩小到“一个房间”。
*   **心法**：胆大心细，小步快跑，监控先行。
