# CQRS (命令查询职责分离)

将系统的 **“写入逻辑（改变状态）”** 与 **“读取逻辑（展现状态）”** 从架构层面彻底分离的模式。它解决了由于读写需求极端不对称导致的系统性能和模型设计难题。

## 1. 痛点：沉重的全能模型

在传统的 CRUD 系统中，我们用同一个 `Domain Entity` 处理读和写：

```java
// 既要支持后台复杂的业务校验，又要支持前台秒级查询
public class Product {
    private String id;
    private String name;
    private List<PriceHistory> history; // 只有写逻辑关心
    private InventoryDetails inventory; // 写逻辑校验用
    private String seoMeta;            // 读展示用
    // ... 100 个字段
}
```

*   **读取性能慢**：前端只需要显示 `name` 和 `price`，你却不得不 JOIN 了 10 张表把整个对象查出来。
*   **写压力干扰**：为了支持复杂的读聚合（Sum/Count），数据库被建了大量索引，导致每插入一条数，索引更新慢得惊人。
*   **代码维护难**：查询代码里混杂着校验逻辑，甚至为了适配查询改动了核心业务对象。

---

## 2. 解决方案：各行其道

CQRS 提出将系统分为两路：

### Command 端 (写路径)
*   **目标**：保证数据完整性和业务规则。
*   **模型**：基于领域模型（Domain Model），数据通常是范式化的（3NF）。
*   **数据存储**：关系型数据库（MySQL/Oracle）。

### Query 端 (读路径)
*   **目标**：极限的查询速度。
*   **模型**：Data Transfer Object (DTO)，扁平化的、面向 UI 展示的。
*   **数据存储**：可能是 Elasticsearch (全文检索), Redis (缓存), 或 ClickHouse (聚合)。

---

## 3. 实现策略与同步

### 策略 A: 共享数据库视图 (低层级)
读写共享一个数据库，读路径直接查询视图。这仅仅是逻辑分离。

### 策略 B: 物理数据库分离 (标准方案)
写完数据库后，通过 **Outbox 模式** 或 **CDC (Binlog)** 发送事件，由监听者更新“读库”。

*   **写操作**：`INSERT INTO products_table ...`
*   **读库同步**：监听者收到消息，组装一个巨大的、扁平的 JSON，写入 Elasticsearch。
*   **查询操作**：前端直接根据 ID 从 ES 拿走那个 JSON，无需任何 JOIN。

---

## 4. 关键挑战：最终一致性

CQRS 的核心代价是 **“读写延迟”**。用户修改完产品名称，点击“保存”后跳回列表页，可能在那 100ms 内看到的依然是旧名字。

*   **处理建议**：
    1.  **UI 欺骗**：前端提交后直接更新本地状态，不依赖立即回显。
    2.  **版本对比**：查询请求带上版本号，如果读库版本没到，提示“正在处理”。

---

## 5. 适用场景建议

1.  **由于查询导致的 DB 瓶颈**：单表几千万，JOIN 太多查不动。
2.  **业务极其复杂**：写逻辑包含大量状态机转换，而读逻辑仅仅是简单报表。
3.  **多端适配**：同一个写逻辑，需要适配 PC 端的详细页和 App 端的简化页。

## 6. 总结
CQRS 不是给系统“排队”，而是给系统“分家”。
*   **优势**：写模型不被查询需求污染；读模型可以针对具体的查询场景做极限优化（如加索引、去范式）。
*   **缺点**：系统复杂度显著提高，不适合常规的 CRUD 管理后台。
