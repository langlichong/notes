# Saga Pattern (Saga 事务模式)

在微服务架构中，解决 **“跨服务长事务一致性”** 的主流模式。它不依赖数据库级别的强重锁，而是通过业务层面的“补偿逻辑”实现最终一致性。

## 1. 痛点：失控的跨服务调用

在单体应用里，我们可以依靠 `@Transactional` 完成一切。但在微服务中：

```java
@Transactional // 这个事务只能控制订单库
void checkout(Cart cart) {
    orderService.create(cart);      // 服务 A (写入订单库)
    inventoryService.deduct(cart);  // 服务 B (跨网络调库存库)
    paymentService.pay(cart);       // 服务 C (跨网络调支付库)
}
```

**死局**：如果 `paymentService.pay` 失败（比如余额不足），前面的 `inventoryService.deduct` 已经把库存扣掉了，由于它是跨库的，本地事务回滚无法撤销对方数据库的修改。

**后果**：用户没付钱，但库存少了，系统产生了“坏账”。

---

## 2. 解决方案：拆分事务与补偿机制

Saga 将长事务拆分为一串 **本地事务 (T1, T2, ..., Tn)**。每个本地事务完成后都会发布一个事件。如果某一步失败，则执行一系列 **补偿事务 (C1, C2, ..., Cn-1)** 来回退之前的操作。

### 核心公式
*   **成功路径**: T1 -> T2 -> T3 (成功完成)
*   **失败路径**: T1 -> T2 -> T3 (失败) -> C2 -> C1 (回滚抹平)

---

## 3. 实现策略

### 策略 A: 协同式 (Choreography) —— 异步广播模式
没有中心指挥官，依靠事件链传递“接力棒”。
*   **流程**：`Order` 创建后发事件 -> `Inventory` 听到后扣库存 -> 发扣成功事件 -> `Payment` 听到后扣钱。
*   **优点**：高度解耦，符合响应式思维。
*   **缺点**：**混乱**。当涉及 10 个服务时，没人能画清这串事件到底是怎么流转的（容易循环依赖）。

### 策略 B: 编排式 (Orchestration) —— 指挥官/状态机模式
有一个中心化的 **Saga 协调器** 负责调度每个服务的调用和补偿。
*   **流程**：协调器定义状态机：先调 A，A 成功调 B；如果 B 失败，下令给 A 执行补偿。
*   **优点**：逻辑集中，流程清晰，易于监控和排查故障。
*   **缺点**：协调器可能成为逻辑中心。

---

## 4. 关键：补偿操作的设计原则

1.  **幂等性**：补偿操作（如退款）可能由于网络原因被调用多次，代码必须能处理“已退过款，不再退”的情况。
2.  **不可撤销性风险**：现实中有些操作无法回滚（如发了短信）。这类不可逆操作应尽量放在 Saga 的最后一步。
3.  **防止中间态干扰**：由于是最终一致性，在回滚完成前，其他业务可能看到“临时状态”。通常需要引入“语义锁”（如锁定资源但不扣减）来规避。

---

## 5. 框架支持

*   **Java (Seata)**: 通过 TCC 模式或 Saga 模式提供开箱即用支持。
*   **Java (AxonFramework)**: 提供了非常成熟的解耦 Saga 编排支持。
*   **中台化工具**: Camunda, Netflix Conductor。

## 6. 总结
Saga 是用**“业务上的回位”**代替了**“数据库上的物理回滚”**。
*   **优势**：极高的伸缩性，不占用数据库连接。
*   **抉择**：如果你能接受用户看到“退款中”这样的中间状态，Saga 是微服务的最佳选择。
