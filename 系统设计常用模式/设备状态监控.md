### tech solustion
1. 时间轮: 如 netty的HashedWheelTimer
2. 响应式编程方案，如RxJava
   ```java
   //在 RxJava 的设计规范（Reactive Streams）中，一切错误（Error）都是终结事件。
  //一旦 timeout 触发，它会向下游发送一个 onError。
  //发送完 onError 后，该流（即针对那个设备的 Observable）会立刻取消订阅并释放资源。
  //后果：如果没有特殊处理，这个设备的监控就此结束，即便它以后再发心跳，你的程序也不会有反应了,
  //方案就是使用 retry()
   rawHeartbeatStream
    .groupBy(Heartbeat::getDeviceId)
    .flatMap(groupedObservable -> {
        String deviceId = groupedObservable.getKey();

        return groupedObservable
            // 只要有心跳进来，立刻执行“上线/在线”逻辑
            .doOnNext(hb -> {
                if (Boolean.TRUE.equals(offlineStatus.get(deviceId))) {
                    sendOnlineNotice(deviceId); // 从离线变回在线
                    offlineStatus.put(deviceId, false);
                }
            })
            // 接下来处理这个单台设备的超时逻辑
            .switchMap(hb -> 
                // 每次收到心跳，switchMap 都会杀掉旧的计时器，开启一个新的
                Observable.timer(20, TimeUnit.SECONDS)
                    .map(t -> "OFFLINE_EVENT") // 如果 20 秒跑完了，发射一个离线事件
            )
            .doOnNext(event -> {
                if ("OFFLINE_EVENT".equals(event)) {
                    sendOfflineAlert(deviceId);
                    offlineStatus.put(deviceId, true);
                }
            });
    })
    .subscribe();
   ```
  ```java
  // 1. 获取原始心跳流（来自 MQTT 或 Redis）
Observable<Heartbeat> rawHeartbeatStream = getMqttStream("heartbeat_topic");

rawHeartbeatStream
    // 2. 按设备 ID 分组
    .groupBy(Heartbeat::getDeviceId)
    // 3. 对每一组设备流进行并发处理
    .flatMap(groupedObservable -> {
        String deviceId = groupedObservable.getKey();
        
        return groupedObservable
            // 在每一台设备的小流上设置 20s 的超时
            .timeout(20, TimeUnit.SECONDS)
            // 虽然设置了超时，但我们要处理这个错误，防止整个流崩溃
            .doOnError(e -> {
                if (e instanceof TimeoutException) {
                    System.err.println("ALERT: Device [" + deviceId + "] is OFFLINE!");
                    // 在此处执行你的告警逻辑，比如发邮件、改数据库状态
                }
            })
            // 4. 重要：发生超时（错误）后，利用 retry 重新订阅这个小组
            // 这样当设备下次发送心跳时，监控会自动恢复，而不会因为一次超时就终结
            .retry() 
            // 切换到 IO 线程处理，避免阻塞主接收线程
            .subscribeOn(Schedulers.io());
    })
    .subscribe(
        data -> { /* 此处处理正常到达的心跳，如果逻辑需要 */ },
        error -> { /* 处理无法恢复的严重错误 */ }
    );
  ```
