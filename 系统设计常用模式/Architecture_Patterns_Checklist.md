# 架构设计模式 Checklist (42种经典模式) - 含实战示例

本文档总结了分布式系统、微服务架构及云原生应用中最经典的 42 种设计模式。你可以将其作为**架构评审 Checklist**，在设计系统时逐一检视，根据具体的业务痛点选择合适的模式。

---

## 一、 数据一致性与事务类 (Consistency & Transaction)

| 模式名称                                | 核心痛点                            | 典型示例 (Real World Example)                                                                                                                                                                                                           |
| :-------------------------------------- | :---------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. Outbox Pattern** <br> (发件箱模式) | **“写库后发消息”的一致性**。        | **用户注册发优惠券**： <br> `user_service` 注册用户时，不直接调 Kafka API，而是往同库的 `outbox` 表插一条 `USER_CREATED` 记录。后台有个 CDC 进程扫描该表并发送到 Kafka，确保哪怕 JVM 崩溃，消息也不丢。                                 |
| **2. Saga Pattern** <br> (Saga 事务)    | **长事务的一致性** (无分布式事务)。 | **携程订票**： <br> 用户下单 -> 1. 扣机票库存 (成功) -> 2. 扣酒店库存 (失败，没房了) -> 3. 触发 Saga 回滚 -> 执行反向操作：把刚才扣的机票库存加回去 -> 通知用户预订失败。                                                               |
| **3. CQRS** <br> (命令查询分离)         | **读写性能/模型冲突**。             | **知乎/微博 Feed 流**： <br> **写(Command)**：用户发帖，写入 MySQL 规范化表，逻辑复杂（验敏、关联话题）。 <br> **读(Query)**：通过 Binlog 同步到 Redis 或 Elasticsearch 宽表。用户刷首页时，直接从 ES 读出拼装好的大 JSON，速度毫秒级。 |
| **4. Event Sourcing** <br> (事件溯源)   | **审计与回溯**。                    | **Git 版本控制**： <br> Git 不只保存文件的“最终内容”，而是保存每一次“Commit (Diff)”。你想知道 3 年前代码啥样？重放 Commit 即可。银行核心账务系统同理，为了绝对的审计合规。                                                              |
| **5. Idempotency Key** <br> (幂等键)    | **超时重试导致重复操作**。          | **支付接口防重**： <br> 支付宝调用银行扣款时，Header 带着 `request_id=uuid-123`。银行系统发现 `uuid-123` 已经在 1 分钟前处理成功了，直接返回 `SUCCESS`，不再扣用户余额。                                                                |
| **6. Cache-Aside** <br> (旁路缓存)      | **缓存与 DB 一致性**。              | **商品详情页**： <br> 查询：先查 Redis，没命中查 MySQL 并回填 Redis。 <br> 更新：运营改价格 -> 先改 MySQL -> **然后直接删除 Redis Key** (而不是更新它)。如果删除失败，通过消息队列重试删除。                                            |

---

## 二、 稳定性与高可用类 (Stability & Availability)

| 模式名称                                | 核心痛点           | 典型示例 (Real World Example)                                                                                                                                                                                     |
| :-------------------------------------- | :----------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **7. Circuit Breaker** <br> (熔断器)    | **雪崩效应**。     | **股票行情服务**： <br> 交易 App 首页调用“行情接口”。如果行情服务挂了（5秒超时），首页不能白屏。App 里的熔断器打开，直接在页面显示“暂无数据”或缓存旧数据，不再去连行情服务，保护 App 主线程不卡死。               |
| **8. Bulkhead** <br> (舱壁隔离)         | **资源耗尽**。     | **Tomcat 线程池隔离**： <br> 一个 Java Web 应用同时提供 `核心支付API` 和 `非核心报表API`。配置两个独立的 ThreadPool。即便报表查询太慢把线程池 B 占满了，支付请求依然能进入线程池 A 正常执行。                     |
| **9. Rate Limiting** <br> (限流)        | **流量洪峰**。     | **12306 抢票 / 抖音直播间**： <br> 接口入口处放置令牌桶算法。每秒只允许 10 万个请求通过，多余的请求直接返回 HTTP 429 "拥挤，请稍后再试"，保护后端 DB 不被瞬间打崩。                                               |
| **10. Retry w/ Backoff**<br> (指数退避) | **网络抖动**。     | **调用短信网关**： <br> 发送短信失败。策略：立刻重试？No。第1秒重试 -> 失败 -> 第2秒重试 -> 失败 -> 第4秒重试 -> 失败 -> 第8秒... 避免把对方网关打死。                                                            |
| **11. Poison Pill** <br> (毒丸/死信)    | **死循环处理**。   | **订单处理 Worker**： <br> 队列里有一条 JSON 缺少 `order_id` 字段的消息。代码一解包就抛 NullPointer 异常，回滚，消息回队列头。这样循环 5 次后，MQ 自动把这条消息踢到 `DLQ_ORDER` 队列，并报警让程序员人工修数据。 |
| **12. Throttling** <br> (节流/分级)     | **VIP 体验保障**。 | **百度网盘下载**： <br> 非会员用户：限速 100KB/s (Token Bucket 投放慢)。 <br> 超级会员：不限速 (或分配专属的高带宽下载服务器)。                                                                                   |
| **13. Health Check** <br> (健康检查)    | **进程僵死**。     | **K8s livenessProbe**： <br> 这是一个 Java 进程，虽然 PID 还在，但 JDBC 连接池已经泄露光了，所有请求都卡住。K8s 每 10 秒调一下 `/actuator/health`，发现返回 500 DB Error，立刻重启该 Pod。                        |

---

## 三、 部署与运维类 (Deployment & Ops)

| 模式名称                                 | 核心痛点                  | 典型示例 (Real World Example)                                                                                                                                                                                         |
| :--------------------------------------- | :------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **14. Blue-Green** <br> (蓝绿部署)       | **发布停机风险**。        | **金融系统大版本升级**： <br> 凌晨 2 点。蓝环境跑 v1.0，绿环境部署 v2.0。测试绿环境没问题。修改 Nginx 配置，瞬间把流量从蓝指向绿。如果发现 v2.0 有致命 Bug，1 秒钟切回蓝环境。                                        |
| **15. Canary Release** <br> (金丝雀)     | **新版本 Bug 影响范围**。 | **微信新功能上线**： <br> “朋友圈大视频”功能。先只对“广州地区 + 内部员工”开放灰度。观察 server 负载和崩馈率。没问题后扩大到广东，最后全量推向全国。                                                                   |
| **16. Sidecar** <br> (边车模式)          | **异构语言治理**。        | **Istio / Envoy**： <br> 你的 PHP 写的旧 API 服务，不懂如何做“熔断”和“分布式追踪”。在 Pod 里加一个 Envoy 容器（Sidecar）。PHP 只管发 HTTP，Envoy 劫持流量帮你做熔断、重试、上报 Jaeger 链路数据。                     |
| **17. Ambassador** <br> (大使模式)       | **容器内代理**。          | **连接 Consul**： <br> 一个 Python 脚本需要从 Consul 读取配置，但不想引入复杂的 Consul Client 库。在 Pod 里跑一个 `consul-agent` 作为大使。Python 脚本只访问 `localhost:8500`，由大使代理去连真正的 Consul 集群。     |
| **18. Claim Check** <br> (提取码模式)    | **大文件传输**。          | **OCR 身份证识别服务**： <br> 二进制图片太大（5MB），不适合直接塞进 RabbitMQ。 <br> 1. 上传图片到 MinIO (S3)，得到 URL。 <br> 2. 发送 `{ "image_url": "s3://..." }` 到 MQ。 <br> 3. 消费者根据 URL 下载图片进行识别。 |
| **19. Leader Election**<br> (领导者选举) | **脑裂/任务重复**。       | **定时报表生成**： <br> 部署了 3 个 `ReportService` 实例。每天凌晨 0 点，只能有一个人去跑“月结报表”。启动时它们都去 Redis 抢 `SET NX` 锁。抢到的实例由于持有锁，成为 Leader 开始跑任务，另外 2 个当备胎。             |

---

## 四、 代码结构与 API 设计类 (Structure & API)

| 模式名称                                 | 核心痛点             | 典型示例 (Real World Example)                                                                                                                                                                                                               |
| :--------------------------------------- | :------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **20. Strangler Fig** <br> (绞杀榕/迁移) | **遗留系统重构**。   | **老旧 ASP.NET 商城重构为 Java 微服务**： <br> 在前面挡一层 Nginx。 <br> 1. 开发 Java 版“购物车服务”。 <br> 2. 配置 Nginx 把 `/api/cart/*` 转发到 Java，其他流量还在 ASP.NET。 <br> 3. 逐步蚕食，直到 ASP.NET 没人访问。                    |
| **21. BFF** <br> (后端服务前端)          | **多端接口适配**。   | **Netflix 视频应用**： <br> 电视端 App：需要高清封面图、电影简介、演职员表（信息密度大）。 <br> 手机端 App：只需要缩略图、标题（省流量）。 <br> 于是开发了 `TV-BFF` 和 `Mobile-BFF` 两个微服务，分别调用底层数据组装不同的 API 返回给前端。 |
| **22. Anti-Corruption** <br> (防腐层)    | **烂代码传染**。     | **对接旧 ERP 系统**： <br> 老 ERP 里的字段叫 `F_Money_01`, `T_User_X`。 <br> 新的微服务建立一个 Adapter 层，把这些烂字段映射为 `Amount`, `UserName`。业务逻辑层只使用干净的新对象，绝不碰老对象。                                           |
| **23. Materialized View**<br> (物化视图) | **复杂聚合查询慢**。 | **双11大屏 - 总销售额**： <br> 如果实时 `SELECT sum(price) FROM orders` 需要跑 5 分钟。 <br> 方案：每下一个单，就触发更新 `total_sales` 表（+1单）。大屏直接查这张只有一行数据的表，QPS 10万都没问题。                                      |
| **24. Sharding** <br> (分片)             | **单机容量瓶颈**。   | **用户订单表 (10亿行)**： <br> 使用 ShardingSphere。规则：`user_id % 16`。 <br> 张三 (id=1) 的订单存在 `Order_DB_01`。 <br> 李四 (id=18) 的订单存在 `Order_DB_02`。 <br> 解决了单机硬盘放不下的问题。                                       |

---

## 五、 并发与资源控制类 (Concurrency)

| 模式名称                                     | 核心痛点       | 典型示例 (Real World Example)                                                                                                                                                                                             |
| :------------------------------------------- | :------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **25. Lease** <br> (租约)                    | **锁死**。     | **DHCP IP 分配**： <br> 路由器分配给你 IP 192.168.1.100，租期 2 小时。如果你关机了（没续约），2 小时后这个 IP 会被回收并分给别人。避免 IP 资源枯竭。                                                                      |
| **26. Competing Consumer** <br> (竞争消费者) | **消费积压**。 | **高峰期消息处理**： <br> RabbitMQ 里的 `email_queue` 积压了 100 万封邮件待发。 <br> 运维利用 K8s HPA，瞬间把 `EmailWorker` 服务从 2 个实例扩容到 50 个。这 50 个实例同时监听同一个 Queue，疯狂抢任务处理，迅速消灭积压。 |

---

## 六、 API 网关与服务治理类 (Gateway & Service Governance)

| 模式名称                                                 | 核心痛点                       | 典型示例 (Real World Example)                                                                                                                                                                                                                   |
| :------------------------------------------------------- | :----------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **27. API Gateway** <br> (API 网关)                      | **统一入口与横切关注点**。     | **电商平台网关**： <br> 所有前端（App/Web）请求先到 Kong/Spring Cloud Gateway。 <br> 网关统一处理：身份认证（JWT验证）、限流（每秒10万）、日志记录、协议转换（HTTP->gRPC）、路由策略。 <br> 微服务专注纯业务逻辑。                              |
| **28. Database per Service** <br> (数据库隔离)           | **微服务数据耦合**。           | **订单与库存服务**： <br> 错误做法：Order 和 Inventory 服务共享一个 DB。 <br> 正确做法：Order 有自己的 PostgreSQL，Inventory 有自己的 MySQL。<br> 跨服务数据通过 API/事件同步。保证服务独立演进、独立扩容、故障隔离。                           |
| **29. External Configuration Store** <br> (配置中心)     | **配置散乱与热更新**。         | **Spring Cloud Config + Nacos**： <br> 有 100 个微服务。不能每个都写死 DB 地址在 jar 里。<br> 方案：所有配置存 Nacos。服务启动时从 Nacos 拉取。运维修改配置后，服务自动刷新（`@RefreshScope`），无需重启。                                      |
| **30. Service Registry & Discovery** <br> (服务注册发现) | **服务地址硬编码与动态变化**。 | **微服务互相调用**： <br> Order 服务要调 User 服务。不能写死 IP。<br> 方案：User 启动时注册到 Nacos（`user-service: 192.168.1.10:8080`）。<br> Order 通过服务名 `user-service` 查询 Nacos 获取实例列表。<br> 实例挂了自动摘除，新实例自动加入。 |

---

## 七、 数据库与存储优化类 (Database & Storage Optimization)

| 模式名称                                          | 核心痛点                    | 典型示例 (Real World Example)                                                                                                                                                                                               |
| :------------------------------------------------ | :-------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **31. Read Replica (读写分离)** <br> (读副本)     | **读占用 95%，写占用 5%**。 | **新闻网站**： <br> 主库（Master）：只处理写操作（发布文章、评论）。<br> 从库（Slave）：3 台，处理所有查询。<br> 利用 MySQL 主从复制 + 中间件（ShardingSphere）自动路由。<br> 写吞吐不变，读吞吐提升 3 倍。                 |
| **32. Queue-Based Load Leveling** <br> (削峰填谷) | **流量脉冲式爆发**。        | **秒杀系统**： <br> 晚上 8 点，10 万人同时点击"购买"。<br> 如果直接调用库存服务，DB 瞬间被打死。<br> 方案：请求先放 RabbitMQ。消费者以恒定速度（每秒 1000 个）处理订单。<br> 前端显示"排队中...预计 2 分钟"。保护后端稳定。 |

---

## 八、 异步与并行处理类 (Asynchronous & Parallel Processing)

| 模式名称                                        | 核心痛点                 | 典型示例 (Real World Example)                                                                                                                                                                                                                                            |
| :---------------------------------------------- | :----------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **33. Async Request-Reply** <br> (异步请求应答) | **长时间任务阻塞连接**。 | **视频转码服务**： <br> 用户上传 1GB 视频。转码需要 20 分钟。<br> 错误做法：HTTP 请求等 20 分钟（超时）。<br> 正确做法：<br> 1. 接口立即返回 `{job_id: 123, status: "processing"}`。<br> 2. 后台异步转码。<br> 3. 前端轮询 `/status/123` 或通过 WebSocket 推送完成通知。 |
| **34. Scatter-Gather** <br> (分散-聚合)         | **并行调用多服务聚合**。 | **机票比价网站**： <br> 用户搜"北京到上海"。<br> 系统需要同时调用：东航API、国航API、南航API（各 2 秒）。<br> 串行调用需要 6 秒。<br> 方案：并发发起 3 个请求，等待所有结果返回（或最多等 3 秒），聚合展示。<br> 总耗时 = max(2,2,2) = 2 秒。                            |
| **35. Publisher-Subscriber** <br> (发布订阅)    | **服务间强耦合调用**。   | **订单状态变更通知**： <br> 订单支付成功后，需要通知：库存服务（发货）、积分服务（加分）、短信服务（通知）。<br> 错误做法：Order 直接调 3 个服务 API。<br> 正确做法：Order 发布事件到 EventBus。3 个服务各自订阅。新增通知服务时 Order 代码零改动。                      |
| **36. Pipes and Filters** <br> (管道过滤器)     | **复杂数据处理流程**。   | **日志分析流水线**： <br> 原始日志 -> [解析器] -> [规范化] -> [敏感词过滤] -> [聚合统计] -> 存入 DB。<br> 每个环节是独立的 Filter（可插拔）。通过 Pipe（Kafka/队列）串联。<br> 优势：新增"IP 归属地识别"Filter 无需改其他逻辑。                                          |

---

## 九、 安全与访问控制类 (Security & Access Control)

| 模式名称                              | 核心痛点               | 典型示例 (Real World Example)                                                                                                                                                                                                                                                    |
| :------------------------------------ | :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **37. Valet Key** <br> (代客泊车钥匙) | **直接暴露存储凭据**。 | **用户上传头像到 OSS**： <br> 错误做法：把 OSS 的永久 AccessKey 给前端，前端直接上传。<br> 安全隐患：AccessKey 泄露后，黑客能删你整个 Bucket。<br> 正确做法：<br> 1. 后端生成"临时签名 URL"（STS Token，有效期 5 分钟）。<br> 2. 前端用这个 URL 上传。<br> 3. 5 分钟后自动失效。 |

---

## 十、 API 设计与数据库性能优化类 (API & Database Performance)

| 模式名称                                        | 核心痛点                   | 典型示例 (Real World Example)                                                                                                                                                                                                                             |
| :---------------------------------------------- | :------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **38. Index Table** <br> (索引表模式)           | **非主键查询极慢**。       | **电商订单按手机号查询**： <br> 主表：`orders (id PK, user_id, phone, ...)`。<br> 问题：`WHERE phone='138...'` 全表扫描。<br> 方案：建立索引表 `order_phone_index (phone PK, order_id)`。<br> 查询先查索引表得到 ID，再查主表。查询速度从 5 秒降到 50ms。 |
| **39. Write-Behind Caching** <br> (写后缓存)    | **高频写入压垮数据库**。   | **游戏排行榜积分更新**： <br> 每秒 10 万次积分变化。直接写 DB 必崩。<br> 方案：先写 Redis，每 10 秒批量刷新到 MySQL。<br> 用户看到的是 Redis 实时数据。DB 压力降低 1000 倍。<br> 风险：Redis 挂了丢数据（需配合 AOF 持久化）。                            |
| **40. Time-Series Pattern** <br> (时序数据模式) | **IoT 海量时序数据写入**。 | **10 万设备每秒上报数据**： <br> 写入：100 万 TPS。查询：按时间范围聚合。<br> MySQL 扛不住。<br> 方案：使用 InfluxDB / TimescaleDB / ClickHouse。<br> 特点：LSM-Tree 存储，列式压缩，按时间分区。<br> 查询性能提升 100 倍。                               |
| **41. Cursor Pagination** <br> (游标分页)       | **深分页性能灾难**。       | **翻到第 100 万页**： <br> `OFFSET 1000000 LIMIT 20` → DB 需要跳过 100 万行。<br> 方案：游标分页 `WHERE id > last_id LIMIT 20`。<br> 前端记住上一页最后的 ID。<br> 无论翻到多少页，查询都是索引扫描，性能恒定。                                           |
| **42. Batch Processing** <br> (批量处理)        | **单条操作开销大**。       | **导入 10 万条订单**： <br> 逐条 INSERT：10 万次网络往返 + 10 万次事务提交。<br> 方案：批量 INSERT（每次 1000 条）。<br> 耗时从 30 分钟降到 2 分钟。<br> 注意：批次太大会锁表，建议 500-1000 条/批。                                                      |

