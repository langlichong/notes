# Linux 网络监控核心指标：Recv-Q 与 Send-Q 深度解析

在 Linux 系统中，通过 `ss` 或 `netstat` 命令查看网络连接时，`Recv-Q` (Receive Queue) 和 `Send-Q` (Send Queue) 是最重要的性能评估窗口。它们是内核中套接字（Socket）缓冲区的具体体现。

---

## 1. 核心模型：两套完全不同的逻辑

`Recv-Q` 和 `Send-Q` 的含义并非固定不变，它们会根据 Socket 的 **连接状态** 发生语义上的彻底切换。

### A. 非监听状态（如 ESTABLISHED, CLOSE_WAIT 等）
这时它们代表的是**数据字节量**。
- **Recv-Q**：内核已经接收并校验通过，但**尚未被用户空间程序**（如 Java, Nginx）调用 `read` 或 `recv` 读取的字节数。
- **Send-Q**：用户程序已经通过 `write` 或 `send` 发送，但**尚未得到对端确认（ACK）**的字节数（仍在本地发送缓冲区中，可能已发出去但没收到 ACK，也可能因为滑动窗口满了还没发出去）。

### B. 监听状态（LISTEN）
这时它们代表的是**连接个数**，与 TCP 的三次握手队列相关。
- **Recv-Q**：当前 **全连接队列（Accept Queue）** 中的连接数。即：已经完成三次握手，正在等待应用程序调用 `accept()` 取走的连接个数。
- **Send-Q**：全连接队列的 **最大允许长度**（Backlog 限制）。

---

## 2. 状态对比表

| Socket 状态 | Recv-Q 含义 | Send-Q 含义 | 异常表现 |
| :--- | :--- | :--- | :--- |
| **Established** | 用户程序**读取慢** (Bytes) | 对端主机**接收慢/网络堵** (Bytes) | 堆积越大，延迟越高 |
| **Listen** | 等待 `accept` 的**连接数** (Count) | 队列的**最大限制** (Count) | Recv-Q > Send-Q 时产生连接丢弃 |

---

## 3. 问题诊断与鉴定方法

### 场景一：Established 状态下 Recv-Q 持续很高
- **现象**：`ss -nt` 看到某个连接的 `Recv-Q` 长期维持在几千甚至几万。
- **鉴定**：说明**应用程序是瓶颈**。
- **可能原因**：
    1.  应用处理逻辑太重，导致消费 Socket 数据的速度跟不上网络收包的速度。
    2.  应用发生了 **Full GC** 或线程死锁，导致读取动作完全停止。
    3.  业务线程池过小，任务在应用内存队列中积压。

### 场景二：Established 状态下 Send-Q 持续很高
- **现象**：`ss -nt` 看到 `Send-Q` 堆积。
- **鉴定**：说明**网络路径或对端是瓶颈**。
- **可能原因**：
    1.  **带宽不足**：本地上行带宽打满。
    2.  **对端处理慢**：对方的 `Recv-Q` 满了，导致 TCP 滑动窗口关闭，本端无法发送。
    3.  **网络丢包**：数据包由于链路问题丢失，本端一直在重传（Retransmission），等待 ACK。

### 场景三：Listen 状态下 Recv-Q 接近或等于 Send-Q
- **现象**：`ss -lnt` 展示 `Recv-Q` 几乎达到了 `Send-Q` 的上限。
- **鉴定**：说明**连接建立（握手）速度极快，但 accept() 取走连接的速度太慢**。
- **后果**：新连接将无法建立，客户端会收到 `Connection Refused` 或超时。
- **排查方向**：
    1.  检查服务器 `backlog` 设置：查看 `/proc/sys/net/core/somaxconn`。
    2.  检查应用框架配置（如 Tomcat 的 `acceptCount` 或 Netty 的 `backlog`）。
    3.  检查应用的主事件循环（Reactor 模式中的 Boss 线程）是否被某些同步操作阻塞了。

---

## 4. 常用命令与监控技巧

### 查看当前连接的积压情况 (数据传输)
```bash
# -n: 不解析域名, -t: TCP, -u: UDP, -a: 所有状态
ss -nt
```

### 查看服务端口的连接队列限制 (监听状态)
```bash
# -l: 仅显示监听状态
ss -lnt
```
*输出示例解构：*
`LISTEN  0  128  127.0.0.1:8080`
- `0` 是 `Recv-Q`：说明当前没有积压的已完成握手连接。
- `128` 是 `Send-Q`：说明该端口最大支持 128 个全连接积压。

### 查看系统全局连接丢弃统计
如果怀疑队列溢出，可以使用以下命令查看：
```bash
# 查看由于全连接队列满而被丢弃的连接统计
netstat -s | grep -i "listen"
# 或
ss -s
```
如果输出中 `times the listen queue of a socket overflowed` 的数值在持续增长，说明你的 `Send-Q` (Listen 状态) 配置太小或应用取连接太慢。

---

## 5. 总结

- **Recv-Q 大**：应用收货太慢。
- **Send-Q 大 (Established)**：网络发货太难。
- **Recv-Q 满 (Listen)**：应用来不及迎接新客，大门塞满了。

在进行 Java 性能剖析（结合你的火焰图）时，如果发现 `Recv-Q` 堆积，应重点观察业务线程（Worker 线程）的执行时间；如果发现 `Listen` 状态下 `Recv-Q` 满，应重点观察负责 `accept` 的 Boss 线程是否异常。
