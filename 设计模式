
# Chromium中Command模式：
  将创建于执行的环境相分离，在一个线程中创建行为，在另一个线程中执行行为。Command模式的优点在于，将实现操作与构造操作解耦，这就避免了锁的问题，使得多线程与单线程编程模型统一起来，
  其次，Command还有一个优点，就是有利于命令的组合和扩展，在Chrome中，它 有效统一了同步和异步处理的逻辑。
# Command模式
  Command模式，是一种看上去很酷的模式，传统的面向对象编程，我们封装的往往都是数据，在Command模式下，我们希望封装的是行为。
  这件事在函数式编程中很正常，封装一个函数作为参数，传来传去，稀疏平常的事儿；但在面向对象的编程中，我们需要通过继承、模板、函数指针等手法，才能将其实现。。。
应用Command模式，我们是期望这个行为能到一个不同于它出生的环境中去执行，简而言之，这是一种想生不想养的行为。
我们做Undo/Redo的时候，会把在任一一个环境中创建的Command，放到一个队列环境中去，供统一的调度；在Chrome中，也是如此，
我们在一个线程环境中创建了Task，却把它放到别的线程中去执行，这种寄居蟹似的生活方式，在很多场合都是有用武之地的。

# chrome下同步异步---Chrome的一种异步执行的解决方案
  在Chrome的多线程模型下，同步和异步的编程模型区别就不复存在了，
  如果是这样一个场景：A线程需要B线程做一些事情，然后回到A线程继续做一些事情；
  在Chrome下你可以这样来做：生成一个Task，放到B线程的队列中，在该Task的Run方法最后，会生成另一个Task，
  这个Task会放回到A的线程队列，由A来执行。如此一来，同步异步，天下一统，都是Task传来传去，想不会，都难了。
  
  在Chrome的多线程模型下，加锁这个事情只发生在将Task放入某线程的任务队列中，其他对任何数据的操作都不需要加锁。
  当然，天下没有免费的午餐，为了合理传递Task，你需要了解每一个数据对象所管辖的线程，不过这个事情，与纷繁的加锁相比，真是小儿科了不知道多少倍。
